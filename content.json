{"pages":[],"posts":[{"title":"Class 클래스","text":"자바의 모든 클래스와 인터페이스는 컴파일 후 class파일이 생성된다. Class 클래스는 컴파일 된 class파일을 로드하여 객체를 동적 로드하고, 정보를 가져오는 메서드가 제공된다. Class.forName(“클래스 이름”) 메서드로 클래스를 동적으로 로드함. 동적로딩 컴파일 시에 데이터 타입이 binding 되는 것이 아닌, 실행중에 데이터 타입을 binding 하는 방법. 프로그래밍 시에는 문자열 변수로 처리했다가 런타임시에는 원하는 클래스를 로딩하여 bindi ng 할 수 있나는 장점이 있다. 컴파일 시에 타입이 정해지지 않으므로 동적 로딩시 오류가 발생하면 프로그램의 심각한 장애가 발생 가능하다.","link":"/2022/04/21/Class%20%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"Filter 및 Interceptor","text":"Filter Filter란 Web Application에서 관리되는 영역으로써 Spring Boot Framework에서 Client로 부터 오는 요청/응답에 대해서 최초/최종 단계의 위치에 존재하며, 이를 통해서 요청/응답의 정보를 변경하거나, Spring에 의해서 데이터가 변환되기 전의 순수한 Client의 요청/응답 값을 확인 할 수 있다. 유일하게 ServletRequest, ServletResponse 의 객체를 변환 할 수 있다. 주로 Spring Framework 에서는 request/response의 Logging 용도로 활용하거나, 인증과 관련된 Logic들을 해당 Filter에서 처리한다. 이를 선/후 처리 함으로써, Service business logic과 분리 시킨다. InterceptorInterceptor란 Filter와 매우 유사한 형태로 존재 하지만, 차이점은 Spring Context에 등록된다. AOP와 유사한 기능을 제공 할 수 있으며, 주로 인증 단계를 처리하거나, Logging을 하는 데에 사용한다. 이를 선/후 처리함으로써, Service business logic과 분리 시킨다.","link":"/2022/05/13/Filter%20%EB%B0%8F%20Interceptor/"},{"title":"Git Bash 명령어 정리","text":"Git Bash 명령어 정리 명령어 의미 git config –global user.name “username“ git의 username 설정 git config –global user.email “email“ git의 email 설정 git config –list git의 설정값 출력 git init 새로운 local Repository 생성 git status 현재 git의 상태 확인 git clone 저장소URL 현재 디렉토리에 해당 git clone git add staging Area로 작업한 파일 add git commit local Repository로 변경사항 commit git push remote Repository로 commit한 파일 push git push origin 브랜치명 commit한 내용을 remote repository에 push git branch local branch 리스트 출력 git branch -m master main branch명을 master에서 main으로 변경 git branch 브랜치명 local branch 생성 git branch -D 브랜치명 local branch 삭제 git switch 브랜치명 local branch 이동","link":"/2022/04/09/Git%20Bash%20%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"title":"HTTP","text":"HTTP HTTP(Hyper Text Transfer Protocol)로 RFC 2616에서 규정된 Web에서 데이터를 주고받는 프로토콜이다.이름에는 하이퍼텍스트 전송용 프로토콜로 정의되어 있지만 실제로는HTML, XML, JSON, Image, Voice, Video, Javascript, PDF 등다양한 컴퓨터에서 다룰 수 있는 것은 모두 전송 할 수 있다.HTTP는 TCP를 기반으로 한 REST의 특징을 모두 구현하고 있는 Web 기반의 프로토콜이다.HTTP는 메시지를 주고(Request) 받는(Response) 형태의 통신 방법이다. Client Server 요청 메시지 작성 ↗요청대기 요청 메시지 전송 요청메시지 수신 응답대기 ↗ 요청 메시지 해석 응답 메시지 수신↖ 애플리케이션 할당 응답 메시지 해석 애플리케이션 결과 생성 데이터 표시 및 처리 ↖응답 메시지 송신 HTTP의 요청을 특정하는 Method는 8가지가 있다.REST 를 구현하기 위한 인터페이스이니 알아둬야 한다. 의미 CRUD 멱등성 안정성 Path Variable Query Parameter DataBody GET 리소스취득 R O O O O X POST 리소스 생성, 추가 C X X O △ O PUT 리소스 갱신, 생성 C / U O X O △ O DELETE 리소스 삭제 D O X O O X HEAD 헤더 데이터 취득 - O O - - - OPTIONS 지원하는 메소드 취득 - O - - - - TRACE 요청메시지 반환 - O - - - - CONNECT 프록시 동작의 터널 접속으로 변경 - X - - - - GET에도 RequestBody를 포함할 수 있지만 표준이 아니기때문에 권장하지 않는다.멱등성 : 몇번의 요청을 해도 같은 응답이 오는지안정성 : 서버에 데이터를 계속 요청을 해도 데이터가 변화되거나 삭제가 되지 않고 위험성이 없는지 HTTP Status Code : 응답 상태를 나타내는 코드 코드명 의미 내용 1XX 처리중 처리가 계속 되고 있는 상태. 클라이언트는 요청을 계속 하거나 서버의 지시에 따라서 재요청 2XX 성공 요청의 성공 3XX 리다이렉트 다른 리소스로 리다이렉트. 해당 코드를 받았을 때는 Response의 새로운 주소로 다시 요청 4XX 클라이언트 에러 클라이언트의 요청에 에러가 있는 상태. 재전송 하여도 에러가 해결되지 않는다. 5XX 서버에러 서버 처리 중 에러가 발생한 상태. 재 전송 시 에러가 해결 되었을 수도 있다. 자주 사용되는 코드 코드명 의미 200 성공 201 성공. 리소스를 생성 성공 301 리다이렉트. 리소스가 다른 장소로 변경됨을 알림. 303 리다이렉트, Client에서 자동으로 새로운 리소스로 요청 처리 400 요청 오류, 파라미터 에러 401 권한 없음 (인증 실패) 404 리소스 없음 (페이지를 찾을 수 없음) 500 서버 내부 에러 (서버 동작 처리 에러) 503 서비스 정지 (점검 등등)","link":"/2022/05/19/HTTP/"},{"title":"Java","text":"Java의 역사 Java는 C와 C++은 포인터로 메모리를 직접 핸들링을 해서 시스템이 다운될 확률이 높아 더 안정적인 언어가 없을까 해서 썬 마이크로시스템즈의 제임스 고슬링과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린프로젝트라는 이름으로 시작해서 1995년에 정식 발표했다. (Java의 초기 이름은 오크(Oak) or 그린(Green)) 최초의 Java는 C++를 약간 변형한 형태로 가전제품에 내장된 프로그램을 위한 언어로 만들어 졌지만 현재의 자바는 웹앱과 모바일 프로그램 개발까지 폭넓게 사용되고 있다. Java의 특징 WORA(Write Once Run Anywhere)가 가능해 플랫폼에 영향을 받지 않으므로 다양한 환경에서 사용가능하다. 객체지향 언어이기 때문에 유지보수가 쉽고 확장성이 좋다 프로그램이 안정적이다 풍부한 기능이 제공되는 오픈 소스이다. 소스: 프로그래밍 언어로 작성된 텍스트 파일 컴파일: 소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정 바이트파일: 자바 가상 기계(JVM)에서 실행 가능한 바이너리 코드 파일 JVM(Java Virtual Machine): 각기 다른 플랫폼에서 동일한 자바 실행 환경 제공. JVM 자체는 플랫폼에 종속적이다. 객체와 클래스 객체란? 클래스의 모양 그대로 찍어낸 실체 프로그램 실행중에 생성되는 실체 메모리 공간을 갖는 구체적인 실체 인스턴스(instance)라고도 부른다. 클래스란? 객체를 만들어내기 위한 설계도 혹은 틀 객체의 속성(state)과 행동(behavior) 포함. 예) 클래스 객체 사람 나, 너, 이웃집아저씨 붕어빵틀 구워진 붕어빵 여러개 소나타 자동차 출고된 실제 소나타 20대 객체지향 프로그래밍(OOP)이란? 프로그램의 구현을 시간의 흐름순이 아닌 객체간의 관계와 협력을 기반으로 프로그래밍 하는것이다. 객체지향 프로그래밍의 장점 소프트웨어의 생산성 향상 컴퓨터 산업의 발전에 따라 소프트웨어의 생명 주기(Life Cycle)단축 소프트웨어를 빠른 속도로 생산할 필요성 증대 객체지향 언어 캡슐화, 상속, 다형성, 객체 등 소프트웨어 재사용을 위한 여러 장치가 내장되있음. 소프트웨어 재사용과 부분 수정이 빠름 소프트웨어를 다시 만드는 부담 줄어들음 소프트웨어 생산성 향상. 실세계에 대한 쉬운 모델링 컴퓨터 산업 초기때는 수학계산/통계 처리를 하는 등의 처리과정, 계산 절차가 중요했지만 현대에는 절차나 과정보다 물체(객체)들의 상호작용으로 묘사하는 것이 용이해졌기 때문 보안성 향상 객체지향의 캡슐화 특징으로 실제 구현되는 부분을 외부에서 볼 수 없으므로 정보 은닉 가능. 객체지향 프로그래밍의 단점 느린 개발속도 모든 객체의 역활과 기능을 이해해야 하기 때문에 프로그래밍에 많은 시간이 소모된다. 느린 실행속도 절차지향 프로그래밍에 비해 느린 실행속도 메모리와 연산에 대한 비용이 증가한다. 높은 난이도 절차지향 프로그래밍에 비해 난이도가 높다. 객체지향 언어(Object-oriented Language) 객체지향 언어란 프로그램을 다수의 객체로 만들고, 이 객체끼리 서로 상호작용 하도록 만드는 프로그래밍 언어이다. 여기서 객체란, 현실로 따지면 TV, 책, 냉장고, 컴퓨터, 카메라 등이 모두 객체인 것이다. 객체는 객체마다 고유한 특성과 행동을 가진다. 객체지향 언어의 특징 캡슐화 (encapsulation) 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것 외부의 접근으로 부터 객체를 보호해 준다. 데이터와 코드의 형태를 외부에서 알 수 없다. 상속 (inheritance) 상위 객체의 속성이 하위 객체에 물려지는것 하위 객체가 상위 객체의 속성을 모두 가지는 관계 Java는 클래스의 다중 상속이 불가능하다. 하지만 인터페이스 다중 상속은 가능하다. 다형성 (polymorphism) 상속과 연관된 개념으로, 같은 이름의 메소드나 클래스가 객체에 따라 다르게 동작하도록 구현한 것 다시말해, 하나의 객체가 다른 여러 객체로 재구성 되는 것이다. 오버로딩(Overloading), 오버라이딩(Overriding)이 있다. 오버로딩(Overloading): 같은 이름인 함수를 여러개 정의한 후 매개변수를 다르게 하여 각자 다르게 동작하는 것 오버라이딩(Overriding): 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현한 것 추상화 (abstraction) 객체들의 공통된 특징(기능, 속성)을 도출하는 것이다. 클래스를 정의하는 것을 추상화라고 할 수 있다.","link":"/2022/04/05/Java%EB%9E%80/"},{"title":"Linux명령어","text":"Linux는 리누즈 토발즈가 작성한 커널 혹은 GNU 프로젝트의 라이브러리와 도구가 포함된 운영체제 Kernal 하드웨어와 응용프로그램을 이어주는 운영체제의 핵심 시스템소프트웨어 Shell 운영체제의 커널과 사용자를 이어주는 소프트웨어 Linux 명령어 명령어 의미 cd 경로이동 cat 텍스트파일 내용보기 vi Vim 에디터로 열기 mkdir 디렉토리 생성 pwd 현재 경로확인 touch 텍스트형식 파일 생성 mv 파일이동 rm 파일삭제 rm -rf 디렉토리 삭제","link":"/2022/04/08/Linux%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"title":"Markdown 문법 정리","text":"마크다운(Markdown) 문법 정리목차 띄어쓰기(여러번) 줄바꿈 제목 강조 구분선 인용구 목록(리스트) 코드블럭 링크 이미지 테이블(표) 주석 윗/아랫첨자 제목(Header) &lt;h1&gt; ~ &lt;h6&gt; 까지 제목을 표현할 수 있다.# ~ ###### 예시 123456# 제목1## 제목2### 제목3#### 제목4##### 제목5###### 제목6 ↓결과 제목1제목2제목3제목4제목5제목6 띄어쓰기(여러번) Markdown은 띄어쓰기를 여러번 입력해도 하나로 인식해버린다.그래서 띄어쓰기를 여러번 할 수 있는 방법이 두가지 있다. 1. 공백 특수문자 사용하기 ( &amp;nbsp; 또는 &amp;#160; )예시 1여러번&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;띄어쓰기를&amp;#160;&amp;#160;&amp;#160;&amp;#160;하고싶다 ↓결과 여러번&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;띄어쓰기를&amp;#160;&amp;#160;&amp;#160;&amp;#160;하고싶다(블로그 테마를 바꾸니까 이 방식으로 띄어쓰기가 되지 않는다……) 2. 전각문자로 띄어쓰기전각 문자는 한국어 키보드로는 입력이 불가능하고 일본어나 중국어 키보드일때만 입력이 가능하다. 전각문자 공백 : ( )괄호안에 있는 문자를 복사해서 사용 가능하다. 예시 1전각문자로 띄어쓰기 ↓결과 전각문자로 띄어쓰기 줄바꿈 문장 끝에 띄어쓰기 두번혹은 문장 중간이나 끝에 &lt;br&gt; 로 줄바꿈을 할 수 있다. 예시 123문장 끝에 띄어쓰기를 두번하면 줄이 바뀐다. 이렇게 &lt;br&gt; 띄어쓰기도 &lt;br&gt; 가능 &lt;br&gt; 하다 ↓결과 문장 끝에 띄어쓰기를 두번하면 줄이 바뀐다. 이렇게 띄어쓰기도 가능 하다 강조 예시 123456789101112*이탤릭체* _이탤릭체_ **굵은 폰트** __굵은 폰트__ ***이탤릭 굵은 폰트*** ___이탤릭 굵은 폰트___~~중간선 폰트~~문장 중간에 사용할 경우 **띄어쓰기** 를 사용하는 것이 좋다. ↓결과 이탤릭체이탤릭체 굵은 폰트굵은 폰트 이탤릭 굵은 폰트이탤릭 굵은 폰트 중간선 폰트 문장 중간에 사용할 경우 띄어쓰기 를 사용하는 것이 좋다. 구분선 회색 선을 그어서 줄을 구분할 수 있다. 예시 12345678910---***- - -* * *// `-` 나 `*` 를 3번이상 적으면 상관없이 줄이 그어진다.--------------************** ↓결과 // 3번이상 적으면 상관없이 줄이 그어진다. 인용구(BlockQuotes) &gt;주로 남의 말이나 글, 또는 자료에서 따온 문장을 쓸때 사용한다. 예시 12345678&gt; 인용문1&gt; 중첩인용구1 &gt; 중첩인용구11&gt;&gt; 중첩인용구2&lt;br&gt;&gt;&gt; 중첩인용구22&gt;&gt;&gt; 중첩인용구3 &gt;&gt;&gt; 중첩인용구33 ↓결과 인용문1 중첩인용구1중첩인용구11 중첩인용구2중첩인용구22 중첩인용구3중첩인용구33 목록(리스트) 순서가 없는 리스트 순서대로 숫자로 이루어진 것이 아닌 list-style이 있는 상태이다. - , + , * 서로 혼용이 가능하다. 예시 12345678910+ 리스트P- 리스트M* 리스트S- 리스트1.0 + 리스트1.1 * 리스트1.2 - 리스트1.3 + 리스트1.4 * 리스트 1.5 ↓결과 리스트P 리스트M 리스트S 리스트1.0 리스트1.1 리스트1.2 리스트1.3 리스트1.4 리스트 1.5 순서가 있는 리스트 순서대로 숫자로 이루어진 리스트이다. 예시 12345678910111. 리스트 11. 리스트 21. 리스트 3 // 순서가 있는 리스트 내부의 리스트도 자동으로 정렬된다.1. 리스트 4-1 1. 리스트 4-1-1 1. 리스트 4-1-2 1. 리스트 4-1-3 1. 리스트 4-1-3-1 1. 리스트 4-1-3-2 1. 리스트 4-1-3-3 ↓결과 리스트 1 리스트 2 리스트 3 // 순서가 있는 리스트 내부의 리스트도 자동으로 정렬된다. 리스트 4-1 리스트 4-1-1 리스트 4-1-2 리스트 4-1-3 리스트 4-1-3-1 리스트 4-1-3-2 리스트 4-1-3-3 코드블럭 코드가 한 줄일 경우에는 코드의 앞과 뒤로 ` (싱글쿼테이션(ESC키 밑에 있는 키)) 를 입력해 주면 된다. 예시 1한 줄 코드 `int i = 0;` 이다 ↓결과 한 줄 코드 int i = 0; 이다 코드가 여러 줄일 경우에는 ``` 또는 ~~~ 로 감싸줘야한다. 예시 123456```for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)}``` 123456~~~for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)}~~~ ↓결과 1234for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)} 1234for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)} 링크 외부 링크 인라인 링크: [링크제목](http://www.google.com)결과: 링크제목 참조 링크: 그것은 [여기에][1]있다.1[1]: http://www.google.com 결과: 그것은 여기에있다. url 링크: &lt;http://www.google.com&gt;결과:&amp;nbsp; http://www.google.com 내부 링크 예시 : [링크제목](#링크아이디)결과 : 링크제목 이미지 ![사진이름](사진경로) 예시![고양이](https://cdn.pixabay.com/photo/2019/11/08/11/56/cat-4611189_960_720.jpg) ↓결과 테이블(표) 예시 123456|이름|나이|성별||---|----|----||홍길동|25|남||김나미|30|여||안보영|35|여||대장균|40|남| ↓결과 이름 나이 성별 홍길동 25 남 김나미 30 여 안보영 35 여 대장균 40 남 테이블 정렬 오른쪽 정렬: —: 가운데 정렬: :—: 왼쪽 정렬: :— 예시 123456|이름|나이|성별||:---|:----:|----:||홍길동|25|남||김나미|30|여||안보영|35|여||대장균|40|남| ↓결과 이름 나이 성별 홍길동 25 남 김나미 30 여 안보영 35 여 대장균 40 남 주석 &lt;!-- 주석내용 --&gt; 주석은 출력결과가 나타나지 않는다. 예시 1&lt;!-- 주석내용1234 --&gt; ↓결과 윗/아랫첨자 글자에 제곱2 을 표시하고 싶거나로그log10 를 표시하고 싶을때 사용한다. 예시 12345678이것은 ^윗첨자^이다. 이것도 &lt;sup&gt;윗첨자&lt;/sup&gt; 이다.// ^ 와 ~ 가 안먹힐때는 // &lt;sup&gt;&lt;/sup&gt; 혹은 &lt;sub&gt;&lt;/sub&gt; 로 글자를 감싸주면 된다. 이것은 ~아랫첨자~이다.이것도 &lt;sub&gt;아랫첨자&lt;/sub&gt;이다. ↓결과 이것은 ^윗첨자^이다.이것도 윗첨자 이다. 이것은 아랫첨자이다.이것도 아랫첨자이다.","link":"/2022/04/01/Markdown%EC%A0%95%EB%A6%AC/"},{"title":"Object 클래스","text":"java.lang 패키지 프로그래밍시 import하지 않아도 자동으로 import됨. 많이 사용하는 기본 클래스들이 속한 패키지 String, Integer, System 등등 java.lang.Object 클래스 모든 클래스는 Object를 상속 받는다. 모든 클래스는 Object에서 상속받고 Object 클래스의 메서드 중 일부는 재정의해서 사용할 수 있다. 컴파일러가 extends Object를 추가해준다. Object클래스의 매서드활용 equals() 메서드 두 인스턴스의 주소 값을 비교하여 true/false를 반환한다. 재정의하여 두 인스턴스가 논리적으로 동일함의 여부를 구분한다. 인스턴스가 다르더라도 논리적으로 동일한 경우 true를 반환하도록 재정의가 가능하다.","link":"/2022/04/19/Object%20%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"POJO(Plain Old Java Object) JAVA","text":"POJO ( Plain Old Java Object ) JAVA 순수한 자바 오브젝트를 뜻한다. 역사를 거슬러 올라가보면, 예전엔 EJB가 인기를 끌고,많이 사용하던 시절에는 단순한 자바 오브젝트를 사용해서 개발하는 것이 아닌, EJB에 종속적인 부분으로 개발을 진행했다.그로 인하여, Module의 교체, 시스템 업그레이드시 종속성으로 인하여 불편함 발생했다. POJO 특징1. 특정 규약에 종속 되지 않는다. 특정 Library, Module 에서 정의된 클래스를 상속 받아서 구현하지 않아도 된다. POJO가 되기 위해서는 외부의 의존성을 두지 않고 순수한 JAVA로 구성이 가능해야 한다.2. 특정 환경에 종속 되지 않는다. 만일 특정 비즈니스 로직을 처리 하는 부분에 외부 종속적인 http request, session 등 POJO를 위배한 것으로 간주한다. 또 많이 사용하고 는 있지만 @Annotation 기반으로 설정하는 부분도 엄연히 POJO라고 볼수 없다. POJO Framework Spring, Hibernate 하나의 서비스를 개발하기 위해서는, 시스템의 복잡함, 비즈니스 로직의 복잡함 등 다양한 어려움을 맞이하게 된다. 위의 두 프레임위크는 객체지향적인 설계를 하고 있으며, 또한 POJO를 지향하고 있다. 그러므로 개발자가 서비스 로직에 집중하고 이를 POJO로 쉽게 개발 할 수 있도록 지원하고 있다.","link":"/2022/05/16/POJO(Plain%20Old%20Java%20Object)%20JAVA/"},{"title":"Spring Boot","text":"Spring Boot란 Spring Boot는 단순히 실행되며, 프로덕션 제품 수준의 스프링 기반 어플리케이션을 쉽게 만들 수 있다. Spring Boot 어플리케이션에는 Spring 구성이 거의 필요하지 않다. Spring Boot java -jar 로 실행하는 Java 어플리케이션을 만들 수 있다. Spring Boot 의 특징 Spring 개발에 대해 빠르고, 광범위하게 적용할 수 있는 환경을 제공한다. 어플리케이션 개발에 필수 요소들만 모아두었다. 간단한 설정으로 개발 및 커스텀이 가능하다 기본값 설정이 있지만 설정을 바꿀 수 있다. 간단하고, 빠르게 어플리케이션 실행 및 배포가 가능하다. 대규모프로젝트(운영환경)에 필요한 비 기능적 기능도 제공한다. (보안, 모니터링 등등) 오랜 경험에서 나오는 안정적인 운영이 가능하다 어노테이션 기반으로 바뀌어서 Spring에서 불편한 설정이 없어졌다. (XML 설정 등등) 여러가지 Spring Boot Annotation Annotation 의미 @SpringBootApplication Spring boot application 으로 설정 @Controller View를 제공하는 controller로 설정 @RestController REST API를 제공하는 controller로 설정 @RequestMapping URL 주소를 맵핑 @GetMapping Http GetMethod URL 주소 맵핑 @PostMapping Http PostMethod URL 주소 맵핑 @PutMapping Http PutMethod URL 주소 맵핑 @DeleteMapping Http DeleteMethod URL 주소 맵핑 @RequestParam URL Query Parameter 맵핑 @RequestBody Http Body를 Parsing 맵핑 @Valid POJO Java class의 검증 @Configration 1개 이상의 bean을 등록 할 때 설정 @Component 1개의 Class 단위로 등록 할 때 사용 @Bean 1개의 외부 library로부터 생성한 객체를 등록 시 사용 @Autowired DI를 위한 곳에 사용 @Qualifier @Autowired 사용시 bean이 2개 이상 일 때 명시적 사용 @Resource @Autowired + @Qualifier 의 개념으로 이해 @Aspect AOP 적용시 사용 @Before AOP 메소드 이전 호출 지정 @After AOP 메소드 호출 이후 지정 예외 발생 포함 @Around AOP 이전/이후 모두 포함 예외 발생 포함 @AfterReturning AOP 메소드의 호출이 정상일 때 실행 @AfterThrowing AOP시 해당 메소드가 예외 발생시 지정 Validation Validation이란 프로그래밍에 있어서 가장 필요한 부분이다.특히 Java에서는 null 값에 대해서 접근하려고 할 때 null pointer exception 이 발생 함으로, 이러한 부분을 방지하기 위해서 미리 검증을 하는 과정을 Validation이라고 한다. Validation의 특징 검증해야 할 값이 많은 경우 코드의 길이가 길어 진다. 구현에 따라서 달라 질 수 있지만 Sevice Logic과의 분리가 필요하다. 흩어져 있는 경우 어디에서 검증을 하는지 알기 어려우며, 재사용의 한계가 있다. 구현에 따라 달라 질 수 있지만, 검증 Logic이 변경 되는 경우 테스트 코드 등 참조하는 클래스에서 Logic이 변경되어야 하는 부분이 발생 할 수 있다. Anotation @Size 문자 길이 측정 int Type 불가 @NotNull null 불가 @NotEmpty null,””불가 @NotBlank null, “” , “ “ 불가 @Past 과거 날짜 @PastOrPresent 오늘이거나 과거 날짜 @Future 미래 날짜 @FutureOrPresent 오늘이거나 미래 날짜 @Pattern 정규식 적용 @Max 최대값 @Min 최소값 @AssertTrue/False 별도 Logic 적용 @Valid 해당 object validation 실행","link":"/2022/05/11/Spring%20Boot/"},{"title":"Spring","text":"Spring Spring은 지난 20년 가까지의 세월 동안 단 한번도 자바 엔터프라이즈 어플리케이션 개발의 최고의 자리를 차지중이다. Spring Framework의 구성은 20여가지로 구성되있다. (https://spring.io/projects/spring-framework)이러한 모듈들은 스프링의 핵심 기능(DI, AOP, etc)을 제공해 주며, 필요한 모듈만 선택하여 사용 가능하다. 현재 단일 아키텍처(모놀리스) 마이크로서비스 아키텍처로 변환중이고여기에 맞춰서 스프링도 진화하고 있는 상태이다. 여러 가지 모듈이 있지만 그 중에서 단연Spring Boot, Spring Cloud, Spring Data, Spring Batch, Spring Security 에 중점을 둔다. Spring의 과제는 “테스트의 용이성”, “느슨한 결합” 에 중점을 두고 개발한다. 2000년대 초의 자바 EE 애플리케이션은 작성/테스트가 매우 어려웠으며, 한번 테스트 하기가 번거로웠다.이로 인하여, 느슨한 결합이 된 애플리케이션 개발이 힘든 상태였으며, 특히 데이터베이스와 같이 외부에 의존성을 두는 경우 단위테스트가 불가능했다. Spring의 가장 큰 특징 POJO IoC/DI (의존 관계 주입) AOP (관점 중심 프로그래밍) PSA (이식 가능한 추상화) IoC (Inversion Of Control) 스프링이 다른 프레임워크와 가장 큰 자이점이 IoC를 통한 개발 진행이 가능하다는 점이다. 스프링에서는 class 또는 service간의 데이터를 주고 받는 일반적인 Java 객체를 new로 생성하여 개발자가 관리 하는 것이 아닌 Spring Container에 모두 맡긴다. Container라는 공간에 생성하고자 하는 객체가 이미 만들어져서 들어가있고, singleton의 형태로 관리가 된다. 즉, 개발자에서 -&gt; 프레임워크로의 제어의 객체 관리의 권한이 넘어갔음으로 “제어의 역전”이라고도 한다. DI (Dependency Injection) DI의 장점 의존성으로 부터 격리시켜 코드 테스트에 용이하다. DI를 통하여, 불가능한 상황을 Mock와 같은 기술을 통하여, 안정적으로 테스트가 가능하다. 코드를 확장하거나 변경 할 때 영향을 최소화 한다. (추상화) 순환참조를 막을 수 있다. AOP(관점 지향 프로그래밍) AOP를 사용하여 로깅, 트랜잭션 관리, 시큐리티에서의 적용 등 AspectJ와 같이 완벽하게 구현된 AOP와 통합하여 사용 가능하다. 스프링 어플리케이션은 대부분 특별한 경우를 제외 하고는 MVC 웹 어플리케이션에서는 Web Layer, Business Layer, Data Layer로 정의한다. Web Layer REST API를 제공하며, Client 중심의 로직 적용 Business Layer 내부 정책에 따른 logic을 개발하며, 주로 해당 부분을 개발한다. Data Layer 데이터베이스 및 외부와의 연동을 처리한다. 주요 Annotation Annotation 의미 @Aspect 자바에서 널리 사용하는 AOP 프레임워크에 포함되며, AOP를 정의하는 Class에 할당 @Pointcut 기능을 어디에 적용시킬지, 메소드? Annotation? 등 AOP를 적용 시킬 지점을 설정 @Before 메소드 실행하기 이전 @After 메소드가 성공적으로 실행 후, 예외가 발생 되더라도 실행 @AfterReturning 메소드 호출 성공 실행 시(Not Throws) @AfterThrowing 메소드 호출 실패 예외 발생(Throws) @Around Before / after 모두 제어","link":"/2022/05/09/Spring/"},{"title":"String, StringBuilder, StringBuffer 클래스","text":"String클래스 한번 생성된 String은 불변하다. String을 연결하면 기존의 String에 연결되는 것이 아닌, 새로운 문자열이 생성된다. StringBuilder, StringBuffer 내부적으로 가변적인 char[]를 맴버 변수로 가진다. 문자열을 여러번 연결하거나 변경할때 사용하면 유용함. 새로운 인스턴스를 생성하지 않고 char[] 를 변경함. toString() 메서드로 String 변환 StringBuilder 단일쓰레드를 할 때는 StringBuilder StringBuffer 멀티쓰레드를 할 때는 StringBuffer StringBuffer는 멀티 쓰레드 프로그래밍에서 동기화를 보장해준다.","link":"/2022/04/20/String,%20StringBuilder,%20StringBuffer%20%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"Springboot(2.6.X 이상) 에서 springfox(Swagger) 에러 발생시 해결법","text":"Swagger를 사용하기 위해 Spring boot 프로젝트에 Springfox 3.0.0 을 dependencies에 추가했더니org.springframework.context.ApplicationContextException: Failed to start bean ‘documentationPluginsBootstrapper’; nested exception is java.lang.NullPointerException오류가 발생했다. 그래서 알아보니 SpringBoot 의 버전이 2.6.X 이상일때spring.mvc.pathmatch.matching-strategy 의 기본값이 변한걸 알아냈다. 2.5.X : spring.mvc.pathmatch.matching-strategy = ant_path_matcher2.6.X : spring.mvc.pathmatch.matching-strategy = path_pattern_parser https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.6-Release-Notes#pathpattern-based-path-matching-strategy-for-spring-mvc 해결방법resources 안에 .properties(또는 .yaml(.yml))에 값을 설정해주면 된다. .properties 일경우1spring.mvc.pathmatch.matching-strategy=ant_path_matcher .yaml(.yml) 일경우1234spring: mvc: pathmatch: matching-strategy: ant_path_matcher","link":"/2022/04/16/Springboot(2.6.X%20%EC%9D%B4%EC%83%81)%20%EC%97%90%EC%84%9C%20springfox(Swagger)%20%EC%97%90%EB%9F%AC%20%EB%B0%9C%EC%83%9D%EC%8B%9C%20%ED%95%B4%EA%B2%B0%EB%B2%95/"},{"title":"release version 14 not supported 에러해결법","text":"Eclipse 에서 작업한 프로젝트를 Intellij에서 열어서 테스트코드를 실행해보니 이런 에러가 났다. 이것은 Java Compiler의 Project bytecode version과 Project SDK 의 버전이 맞지 않아서 그런것이다.이 에러의 해결방법을 알아보자. 일단 좌측 상단의 File -&gt; Settings 로 들어가보자. (Ctrl + Alt + S) 그리고 Build, Execution, Deployment -&gt; Compiler -&gt; Java Compiler 로 들어가서 Project bytecode version에서 JAVAC의 버전을 설정해주자. (필자는 11버전) 여기서 이제 테스트코드를 돌렸는데도 에러가 뜨면 아래 내용을 따라해보자. Intellij 좌측 상단의 File -&gt; Project Structure… 를 클릭한다. (Ctrl + Alt + Shift + S) 그리고 Project Settings -&gt; Project 에서 Project SDK 를 설정하는 곳에 자신의 JDK버전을 선택 후 Apply 후 OK 를 클릭한다. 필자는 Project bytecode version 을 JDK 11 로 설정했으니 11버전 선택 만약 목록에 없다면 Add SDK -&gt; JDK 를 클릭 후 자신의 JDK 경로를 설정후 OK -&gt; OK (필자는 C:\\Program Files\\Java\\jdk-11.0.12 였다.) 그러면 이렇게 테스트코드가 잘 실행된다.","link":"/2022/04/07/release%20version%2014%20not%20supported/"},{"title":"객체와 클래스 및 객체지향 언어의 특징","text":"객체와 클래스 객체란? 구체적 추상적 데이터의 단위 객체의 속성은 클래스의 맴버 변수로 선언 한다 클래스의 모양 그대로 찍어낸 실체 프로그램 실행중에 생성되는 실체 메모리 공간을 갖는 구체적인 실체 인스턴스(instance)라고도 부른다. 클래스란? 객체를 만들어내기 위한 설계도 혹은 틀 객체의 속성(state)과 행동(behavior) 포함. 예) 클래스 객체 사람 나, 너, 이웃집아저씨 붕어빵틀 구워진 붕어빵 여러개 소나타 자동차 출고된 실제 소나타 20대 객체지향 프로그래밍(OOP)이란? 프로그램의 구현을 시간의 흐름순이 아닌 객체간의 관계와 협력을 기반으로 프로그래밍 하는것이다. 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징을 뽑아와 프로그래밍 하는것 객체를 정의하고 각 객체의 속성을 맴버 변수로 역활을 매서드로 구현하고 각 객체간의 협력을 구현한다. 객체지향 프로그래밍의 장점 소프트웨어의 생산성 향상 컴퓨터 산업의 발전에 따라 소프트웨어의 생명 주기(Life Cycle)단축 소프트웨어를 빠른 속도로 생산할 필요성 증대 객체지향 언어 캡슐화, 상속, 다형성, 객체 등 소프트웨어 재사용을 위한 여러 장치가 내장되있음. 소프트웨어 재사용과 부분 수정이 빠름 소프트웨어를 다시 만드는 부담 줄어들음 소프트웨어 생산성 향상. 실세계에 대한 쉬운 모델링 컴퓨터 산업 초기때는 수학계산/통계 처리를 하는 등의 처리과정, 계산 절차가 중요했지만 현대에는 절차나 과정보다 물체(객체)들의 상호작용으로 묘사하는 것이 용이해졌기 때문 보안성 향상 객체지향의 캡슐화 특징으로 실제 구현되는 부분을 외부에서 볼 수 없으므로 정보 은닉 가능. 객체지향 프로그래밍의 단점 느린 개발속도 모든 객체의 역활과 기능을 이해해야 하기 때문에 프로그래밍에 많은 시간이 소모된다. 느린 실행속도 절차지향 프로그래밍에 비해 느린 실행속도 메모리와 연산에 대한 비용이 증가한다. 높은 난이도 절차지향 프로그래밍에 비해 난이도가 높다. 객체지향 언어(Object-oriented Language) 객체지향 언어란 프로그램을 다수의 객체로 만들고, 이 객체끼리 서로 상호작용 하도록 만드는 프로그래밍 언어이다. 여기서 객체란, 현실로 따지면 TV, 책, 냉장고, 컴퓨터, 카메라 등이 모두 객체인 것이다. 객체는 객체마다 고유한 특성과 행동을 가진다. 객체지향 언어의 특징 캡슐화 (encapsulation) 캡슐화는 객체의 속성을 보호하기 위해 사용된다. 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것이다. 외부의 접근으로 부터 객체를 보호해 준다. 데이터와 코드의 형태를 외부에서 알 수 없다. Method설계 속성이 선언되었으나, 이의 상태를 변경하는 method가 없다면 잘못 선언된 속성이다. 실물 객체가 가진 기능을 모두 제공해야 한다. 각각의 Method는 서로 관련성이 있어야 한다. 객체 안의 Method는 객체 안의 속성을 처리해야 하며, 다른 객체를 전달받아 해당 다른 객체에 정의 된 속성을 직접 처리하면 안된다. 단, Method에 실행에 필요한 값들은 객체의 형태가 아닌 매개변수의 형태로 전달되어져야 한다. Getter/Setter : 외부에서 내부 속성에 직접 접근하는 것이 아닌 Getter/Setter Method를 통해서 접근하도록 적용해줌. CRUD Method : 데이터 처리를 위한 기본적인 CRUD Method를 제공 Business Logic Method : 비즈니스 로직 처리를 위한 Method를 제공 객체의 생명 주기 처리 Method : 흔히 destroy(), disconnect()등 quit() 등 소멸에 대한 Method 객체의 영구성 관리 Method : 영구성(유효성) 속성에 대한 변경이 필요한 경우 외부에서는 접근이 불가능 하도록 private로 선언하며, 내부의 다른 Method를 통해서 사용 되도록 한다. Method의 속성은 반드시 1개에 속할 필요는 없으며, 여러 속성에 해당 될 수 있다. 장점 객체지향의 패러다임 중 하나인 추상화를 제공한다. 재 사용성이 향상된다. 앞선 이유로 인하여, 유지보수의 효율성이 향상 된다. 무결성 보통의 캡슐화 코딩이라고 하면 주로 변수는 private로 선언하고, Method를 public으로 선언하는 형태를 많이 가지게 된다. 이는 객체의 무결성을 위함이다. Getter/Setter를 제외하고는 public method는 입력된 매개변수를 Validation을 한 후에 실행하는 것을 기본으로 한다. Validation을 통하여 객체의 값을 바꾸거나, 값의 대한 유효성을 가질 수 있다. 상속 (inheritance) 객체지향에서의 상속은 속성의 상속이 아닌, 하위로 내려갈수록 구체화 되는 것이다. 상위 객체의 속성이 하위 객체에 물려지는 것 이다. 하위 객체가 상위 객체의 속성을 모두 가지는 관계이다. Java는 클래스의 다중 상속이 불가능하다. 하지만 인터페이스 다중 상속은 가능하다. 상속의 효과 프로그램 구조에 대한 이해도 향상 최상위 클래스의 구조를 보고, 하위 클래스의 동작을 이해 할 수 있다. 재사용성 향상 상속을 이용하여, 해당 클래스에 필요한 속성 및 메소드를 모두 정의 하지 않고, 상속을 받아서 사용 할 수 있다. 확장성 향상 일관된 형태의 클래스 객체를 추가 할 수 있어, 간단하게 프로그램 확장이 가능하다. 유지보수성 향상 각 객체마다, 자신의 메소드를 정의하고 있다면, 코드 수정에서 많은 작업이 필요하지만, 상속을 사용한 경우 일관된 형태로 작성이 가능하다. 다형성 (polymorphism) 다형성은 하나의 개체가 여러 개의 형태로 변화 하는것을 말하며, 이를 객체지향 에서도 유사하게 사용하고 있다. 상속과 연관된 개념으로, 같은 이름의 메소드나 클래스가 객체에 따라 다르게 동작하도록 구현한 것이다. 다시말해, 하나의 객체가 다른 여러 객체로 재구성 되는 것이다. 다형성을 하기 위해서는 오버라이딩 및 오버로딩을 통해서 사용 가능하다. 오버로딩(Overloading), 오버라이딩(Overriding)이 있다. 오버로딩(Overloading): 같은 이름인 함수를 여러개 정의한 후 매개변수를 다르게 하여 각자 다르게 동작하는 것 오버라이딩(Overriding): 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현한 것 추상화 (abstraction) 객체지향에서의 추상화는 모델링이다. 객체들의 공통된 특징(기능, 속성)을 도출하는 것이다. 클래스를 정의하는 것을 추상화라고 할 수 있다. 구체적으로 공통적인 부분, 또는 특정 특성을 분리해서 재조합 하는 부분이 추상화이다. 다형성, 상속 모두 추상화에 속한다.","link":"/2022/04/12/%EA%B0%9D%EC%B2%B4%EC%99%80%20%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B0%8F%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%96%B8%EC%96%B4%EC%9D%98%20%ED%8A%B9%EC%A7%95/"},{"title":"객체지향 설계 5원칙(SOLID)","text":"좋은 소프트웨어를 설계하기 위해서는 결합도는 낮추고, 응집도는 높혀야 한다. 결합도 : 모듈(클래스)간의 상호 의존 정도를 나타내는 지표로써 결합도가 낮으면 모듈간의 상호 의존성이 줄어들어서 객체의 재사용 및 유지보수가 유리하다 응집도 : 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져, 재사용 및 유지보수가 용이하다. 객체지향 설계 5원칙 (SOLID)단일 책임 원칙(SRP) 어떠한 클래스를 변경해야 하는 이유는 한기지 뿐 이여야 한다, 개방 폐새 원칙(OCP) 자신의 확장에는 열려있고 주변의 변화에 대해서는 닫혀 있어야 한다. 상위 클래스 또는 인터페이스를 중간에 둠으로써, 자신은 변화에 대해서는 퍠쇄적이지만, 인터페이스는 외부의 변화에 대해 확장을 개방해 줄 수 있다. 리스코프 치환 원칙(LSP) 서브 타입은 언제나 자신의 기반(상위)타입으로 교체 할 수 있어야 한다. 인터페이스 분리 원칙(ISP) 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다. 프로젝트 요구 사항과 설계에 따라서 SRP(단일책임원칙)/ISP(인터페이스분리원칙) 를 선택한다. 의존 역전 원칙(DIP) 자신보다 변하기 쉬운 것에 의존하지 말아야 한다.","link":"/2022/05/05/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%84%A4%EA%B3%84%205%EC%9B%90%EC%B9%99(SOLID)/"},{"title":"내부 클래스","text":"내부 클래스 클래스 내부에 선언한 클래스로 이 클래스를 감싸고 있는 외부 클래스와 밀접한 연관이 있는 경우가 많고, 다른 외부 클래스에서 사용할 일이 거의 없는 경우에 내부 클래스로 선언해서 사용한다. 중첩클래스라고도 한다. 내부클래스의 종류 : 정적(static) 내부 클래스, 지역(local) 내부 클래스, 익명(anonymous) 내부 클래스 인스턴스 내부 클래스 내부적으로 사용할 클래스를 선언(private로 선언하는것을 권장) 외부 클래스가 생성된 후 생성된다.(정적 내부 클래스와 다름) private가 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있음. 정적 내부 클래스 외부 클래스 생성과 무관하게 사용할 수 있다. 정적 변수, 정적 메서드 사용. 지역 내부 클래스 지역 변수와 같이 메서드 내부에서 정의하여 사용하는 클래스이다. 메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라진다. 메서드 호출 이후에도 사용해야 하는 경우가 있을 수 있으므로 지역 내부 클래스에서 사용하는 메서드의 지역 변수나 매개 변수는 final로 선언된다. 익명 내부 클래스 이름이 없는 클래스 클래스의 이름을 생략하고 주로 하나의 인터페이스나 하나의 추상 클래스를 구현하여 반환. 인터페이스나 추상클래스 자료형의 변수에 직접 대입하여 클래스를 생성하거나 지역 내부 클래스의 메서드 내부에서 생성하여 반환 할 수 있음. 함수형 인터페이스와 람다식 함수형 인터페이스는 람다식을 선언하기 위한 인터페이스. 익명 함수와 매개변수만으로 구현되므로 인터페이스는 단 하나의 메서드만을 선언해야함 @FunctionalInterface 애노테이션 사용(함수형 인터페이스라는 의미. 내부에 여러 개의 메서드를 선언하면 에러발생) 자바에서는 객체없이 메서드가 호출될 수 없다. 람다식을 구현하면 익명 내부 클래스가 만들어지고 이를 통해서 익명 객체가 생성됨","link":"/2022/05/04/%EB%82%B4%EB%B6%80%20%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"다형성","text":"다형성이란? 객체지향 프로그래밍의 가장 큰 특징중 하나이다. 하나의 코드가 여러 자료형으로 구현되어 실행되는 것 같은 코드에서 여러가지 다른 실행 결과가 나오게 만드는 것 다형성을 잘 활용하면 유연하고 확장성있고 유지보수가 편한 프로그램을 만들 수 있다. 다형성을 사용하는 이유 여러 클래스를 하나의 타입(상위 클래스)으로 핸들링 할 수 있다. 상속과 메서드 재정의를 활용하여 확장성 있는 프로그램을 만들 수 있다. 다형성이 없는 경우, if else 문이 수많이 구현되고, 코드의 유지보수가 어려워진다.","link":"/2022/04/17/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"title":"더블 연결 리스트(DoubleLinkedList)","text":"DoubleLinkedList란 DoubleLinkedList의 특징 Head Node와 Tail Node를 각각 따로 가지고 있다. (둘 다 더미노드) Next Pointer 만 있는게 아닌, Prev Pointer 도 함께 가지고 있다. 그래서 이전노드와 다음노드를 가리키고 있다. 실질적으로 가장 앞에있는 데이터 노드는 Head Node 의 다음 노드에 위치해있다. 가장 마지막에 있는 데이터 노드는 Tail Node 의 이전 노드에 위치해있다. DoubleLinkedList의 추가 (Add) DoubleLinkedList에서는 Tail Node 가 가장 마지막에 위치해 있다. 그래서 데이터 노드를 추가할때는 Tail Node의 prev pointer가 가리키는 곳에 넣어주면 된다. 시간복잡도: O(1) DoubleLinkedList의 검색 (by index) LinkedList와 마찬가지로 순서대로 타고 들어가지만 차이점이 있다. Head와 Tail 중 가장 가까운 노드에서부터 순서대로 타고 들어갈 수 있다. 시간복잡도: O(N) (LinkedList와 같지만 절반의 시간이 들어간다.) DoubleLinkedList의 삽입 (insert) Prev Node 의 Next Pointer와 Current Node 의 prev Pointer 가 삽입할 노드를 가리키게 한다. 그리고 삽입한 노드의 prev Pointer는 Prev Node를, Next Pointer는 Current Node를 가리키게 한다. 시간복잡도: O(1) DoubleLinkedList의 삭제 (delete by index) 삭제할 Node의 prev Node 의 Next Pointer와 next Node의 Prev Pointer를 서로 가리키게 한다. 시간복잡도: O(1)","link":"/2022/05/03/%EB%8D%94%EB%B8%94%20%EC%97%B0%EA%B2%B0%20%EB%A6%AC%EC%8A%A4%ED%8A%B8(DoubleLinkedList)/"},{"title":"디자인 패턴","text":"디자인 패턴 자주 사용하는 설계 패턴을 정형화 해서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계 알고리즘과는 유사 하지만, 명확하게 정답이 있는 형태는 아니며, 프로젝트의 상황에 맞추어 적용 가능하다. Gof 디자인 패턴 소프트웨어를 설계 할 때는 기존에 경험이 매우 중요하다.그러나 모든 사람들이 다양한 경험을 가지고 있을 수는 없다. 이러한 지식을 공유하기 위해서 나온 것이 Gof(Gang of four)의 디자인 패턴이다. 객체지향 개념에 따른 설계중 재사용할 경우 유요한 설계를 디자인 패턴으로 정리 해둔 것이다. Gof의 디자인 패턴은 총 23개 이며, 이를 잘 이해하고 활용한다면, 경험이 부족하더라도 좋은 소프트웨어 설계가 가능하다. 디자인 패턴의 장점 개발자(설계자) 간의 원활한 소통 소프트웨어 구조 파악 용이 재사용을 통한 개발 시간 단축 설계 변경 요청에 대한 유연한 대처가능디자인 패턴의 단점 객체지향 설계/ 구현 초기 투자 비용 부담 생성패턴 객체를 생성하는 것과 관련된 패턴으로, 객체의 생성과 변경이 전체 시스템에 미치는 영향을 최소화 하고, 코드의 유연성을 높혀 준다. 팩토리 매서드(Factory Method)패턴 싱글톤(Singleton)패턴 프로토타입(Prototype)패턴 빌더(Builder)패턴 업스트랙트 팩토리(Abstract Factory)패턴 체이닝(Chaning)패턴(Gof패턴 아님.) 구조패턴 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램 구조를 설계하는데 활용 될 수 있는 패턴 클래스, 객체들의 구성을 통해서 더 큰 구조를 만들 수 있게 해준다. 큰 규모의 시스템에서는 많은 클래스들이 서로 의존성을 가지게 되는데, 이런 복잡한 구조를 개발 하기 쉽게 만들어 주고 유지 보수하기 쉽게 만들어 준다. 어댑터(Adapter)패턴 컴포짓(Composite)패턴 브릿지(Bridge)패턴 데코레이터(Decorator)패턴 파사드(Facade)패턴 플라이웨이트(FlyWeight)패턴 프록시(Proxy)패턴 행위 패턴 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것으로, 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 제공한다. 행위 관련 패턴을 사용하여 독립적으로 일을 처리하고자 할 때 사용된다. 템플릿 메소드(Template Method)패턴 인터프리터(Interpreter)패턴 이터레이터(Iterator)패턴 옵저버(Obsever)패턴 전략(Strategy)패턴 비지터(Visitor)패턴 체인 오브 리스폰시빌리티(Chain of responsibility)패턴 커맨드(Command)패턴 메디에이터(Mediator)패턴 스테이스(State)패턴 메멘토(Memento)패턴","link":"/2022/05/27/%EB%94%94%EC%9E%90%EC%9D%B8%20%ED%8C%A8%ED%84%B4/"},{"title":"배열(Array)","text":"배열(Array)의 특징 선형으로 자료를 관리한다. 정해진 크기의 메모리를 먼저 할당받아 사용하고, 자료의 물리적 위치와 논리적 위치가 같다. 동일한 데이터 타입을 순서에 따라 관리하는 자료구조이다. 처음 크기를 10으로 저장 후 2개의 데이터만 저장해도 실제 배열의 크기는 10이다. 인덱스에 따라 값을 유지하므로 내부값이 삭제되어도 빈자리가 남게 되어 메모리가 낭비되는 단점이 있다. 요소의 추가 또는 제거시 연속적인 형태를 유지하기 위해 다른 요소들의 이동이 필요하다. 배열의 n번째 요소를 찾는 인덱스 연산이 빠르다. 인덱스로 random access가 가능하다.","link":"/2022/04/23/%EB%B0%B0%EC%97%B4(Array)/"},{"title":"메서드 및 메서드의 종류","text":"메서드 메서드의 이름은 주소를 나타낸다 매서드는 명령어의 set이고 프로그램이 로드되면 메서드 영역에 명령어 set이 위치 해당 메서드가 호출 되면 명령어 set이 있는 주소를 찾아 명령어가 실행됨 이때 메서드에서 사용하는 변수들은 스택 메모리에 위치 하게됨 따라서 다른 인스턴스라도 같은 메서드의 코드는 같으므로 같은 메서드가 호출됨 인스턴스가 생성되면 변수는 힙 메모리에 따로 생성되지만 메서드 명령어 set은 처음 한번만 로드 됨 템플릿 메서드 추상 메서드나 구현 된 메서드를 활용하여 코드의 흐름을 정의하는 메서드 final로 선언하여 하위 클래스에서 재정의 할 수 없게 함 프레임워크에서 많이 사용되는 설계 패턴 디폴트 메서드 (JAVA 8 이후) 구현을 가지는 메서드, 인터페이스를 구현하는 클래스들에서 공통으로 사용할 수 있는 기본 메서드 default 키워드 사용 구현하는 클래스에서 재정의 할 수 있다 인터페이스를 구현한 클래스의 인스턴스가 생성 되어아 사용 가능하다 디폴트 메서드가 중복되는 경우에는 구현하는 클래스에서 재정의 하여야 한다. 정적 메서드 (JAVA 8 이후) 인스턴스 생성과 상관없이 인터페이스 타입으로 사용할 수 있는 메서드 private 메서드 (JAVA 9 이후) 인터페이스를 구현한 클래스에서 사용하거나 재정의 할 수 없다. 인터페이스 내부에서만 사용하기 위해 구현하는 메서드 default 메서드나 static 메서드에서 사용한다.","link":"/2022/04/18/%EB%A9%94%EC%84%9C%EB%93%9C%20%EB%B0%8F%20%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98%20%EC%A2%85%EB%A5%98/"},{"title":"빌더(Builder)패턴","text":"빌더(Builder)패턴 점층적 생성자 패턴의 안전성과 자바빈즈 패턴의 가독성을 겸비한 패턴이다.클라이언트는 필요한 객체를 직접 만드는 대신, 필수 매개변수만으로 생성자를 호출해 빌더 객체를 얻는다.빌더 객체가 제공하는 일종의 세터 메서들로 원하는 선택 매개변수들을 설정한다.매개변수가 없는 build 메서드를 호출해 필요한 객체들을 얻는다. 빌더는 생성할 클래스 안에 정적 맴버 클래스로 만들어두는게 일반적이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Member { // 필수 매개변수 private String id; private String name; private String password; private int age; // 선택 매개변수 private String gender; private String address; private String job; public static class Builder{ // 필수 매개변수 private String id; private String name; private String password; private int age = 0; // 선택 매개변수 -&gt; 기본값으로 초기화 private String gender = &quot;&quot;; private String address = &quot;&quot;; private String job = &quot;&quot;; // 필수 매개변수만 받는 생성자 public Builder(String id, String name, String password, int age) { this.id = id; this.name = name; this.password = password; this.age = age; } public Builder gender(String gender){ this.gender = gender; return this; } public Builder address(String address){ this.address = address; return this; } public Builder job(String job){ this.job = job; return this; } public Member build(){ return new Member(this); } } private Member(Builder builder){ id = builder.id; name = builder.name; password = builder.password; age = builder.age; gender = builder.gender; address = builder.address; job = builder.job; } // 값 출력을 위한 toString 오버라이드 @Override public String toString() { return &quot;Member{&quot; + &quot;id='&quot; + id + '\\'' + &quot;, name='&quot; + name + '\\'' + &quot;, password='&quot; + password + '\\'' + &quot;, age=&quot; + age + &quot;, gender='&quot; + gender + '\\'' + &quot;, address='&quot; + address + '\\'' + &quot;, job='&quot; + job + '\\'' + '}'; }} 실행문 12345678910111213141516171819202122public class MainBuilder { public static void main(String[] args) { // 필수 매개변수만 받아 인스턴스 생성하기 Member jung = new Member.Builder(&quot;test1234&quot;, &quot;정재원&quot;, &quot;test5678&quot;, 20) .build(); System.out.println(jung.toString()); // 선택 매개변수까지 받아 인스턴스 생성하기 Member lee = new Member.Builder(&quot;addmore1234&quot;, &quot;lee&quot;, &quot;add1234&quot;, 34) .gender(&quot;male&quot;) .address(&quot;서울특별시 관악구 난우길 4&quot;) .job(&quot;개발자&quot;) .build(); System.out.println(lee.toString()); }} 결과 12Member{id='test1234', name='정재원', password='test5678', age=20, gender='', address='', job=''}Member{id='addmore1234', name='lee', password='add1234', age=34, gender='male', address='서울특별시 관악구 난우길 4', job='개발자'}","link":"/2022/06/03/%EB%B9%8C%EB%8D%94(Builder)%ED%8C%A8%ED%84%B4/"},{"title":"상속","text":"상속 새로운 클래스를 정의 할 때 이미 구현된 클래스를 상속받아서 속성이나 기능을 확장하여 클래스를 구현함 이미 구현된 클래스보다 더 구체적인 기능을 가진 클래스를 구현해야 할 때 기존 클래스를 상속함 extends를 이용하여 상속을 한다. extends 키워드 뒤에는 단 하나의 클래스만 올 수 있다. 자바는 단일상속만 가능하다. 상위클래스는 하위클래스보다 더 일반적인 개념과 기능을 가진다. 하위클래스는 상위클래스보다 더 구체적인 개념과 기능을 가진다. 하위클래스를 생성하면 상위클래스가 먼저 생성된다. 클래스가 상속받은 경우 하위클래스의 생성자에는 무조건 상위클래스의 생성자를 호출한다. super 키워드 하위 클래스에서 가지는 상위 클래스에 대한 참조값이다. super()는 상위 클래스의 기본 생성자를 호출한다. 하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면, super()가 호출된다.(이때 반드시 상위 클래스의 기본 생성자가 존재 해야 한다.) 상위 클래스의 기본 생성자가 없는 경우(다른 생성자가 있는 경우) 하위 클래스의 생성자에서는 super를 활용하여 명시적으로 상위 크래스의 생성자를 호출한다. super는 생성된 상위 클래스 인스턴스위 참조값을 가지므로, super를 이용하여 상위 클래스의 메서드나 맴버 변수에 접근할 수 있음. 상속의 형변환형변환(업캐스팅) 상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스를 생성할 수 있다. 하지만 상위클래스의 요소들만 사용이 가능하다. 상위 클래스 타입의 변수에 하위 클래스 변수가 대입. 형변환(다운캐스팅) 업캐스팅된 클래스를 다시 원래의 타입으로 형 변환 하위 클래스로의 형 변환은 명시적으로 해야함. IS-A 관계 일반적인 개념과 구체적인 개념과의 관계 상속은 클래스간의 결합도가 높은 설계 상위 클래스의 수정이 많은 하위 클래스에 영향을 미칠 수 있음 계층구조가 복잡하거나 hierarchy가 높으면 좋지 않음. HAS-A 관계 클래스가 다른 클래스를 포함하는 관계 코드 재사용의 가장 일반적인 방법 Library를 구현할때 ArrayList를 생성하여 사용 상혹하지 않음. 자바는 다중상속이 불가능하고 단일상속만 가능하다.","link":"/2022/04/15/%EC%83%81%EC%86%8D/"},{"title":"스택(Stack)","text":"스택(Stack) JDK클래스 : stack Stack의 특징 가장 나중에 입력 된 자료가 가장 먼저 출력되는 후입선출(LIFO - Last In First Out) 구조(LIFO) 예) 인터넷 브라우저 뒤로가기, Ctrl + z 가장 먼저 넣은 데이터가 가장 나중에 나오게 된다. 맨 마지막 위치(top)에서만 자료들을 추가, 삭제, 꺼내올 수 있다.(중간의 자료를 꺼낼 수 없다.) 가장 나중에 넣은 데이터가 가장 일찍 나오게 된다. 가장 최근의 자료를 찾아오거나 게임에서 히스토리를 유지하고 이를 무를때 사용가능 Stack에서의 중요한 연산 push() data를 넣는 연산(접시쌓기 개념으로) pop() data를 꺼내오면서 data를 가져오는 연산 top(), peek() data를 그래도 둔 채로 data를 가져오는 연산","link":"/2022/04/26/%EC%8A%A4%ED%83%9D(Stack)/"},{"title":"싱글톤(Singleton)","text":"싱글톤(Singleton)이란? 어플리케이션이 실행될 때, 어떤 클래스가 한번만 메모리에 할당하고, 그 메모리에 인스턴스를 만들어 사용하는 디자인 패턴이다. 다시말해, 객체의 인스턴스가 오직 1개만 생성되는 패턴을 의미한다. 싱글톤(Singleton)의 장점 1. 한번의 new 연산자를 통해 고정된 메모리 영역을 사용하기 때문에 추후 해당 객체에 접근 할 때, 메모리 낭비를 방지할 수 있다. 2. 이미 생성된 인스턴스를 활용해서 속도 측면에도 이점이 있다. 3. 전역으로 사용되는 인스턴스이기 때문에 다른 클래스 간에 데이터 공유가 쉽다. 싱글톤(Singleton)의 단점 1. private 생성자를 가지고 있기 때문에 상속 할 수 없다. 2. 서버환경에서는 싱글턴이 하나만 만들어지는 것을 보장하지 못한다. 3. 싱글톤은 객체지향 프로그래밍에서 권장되지 않는 전역 상태를 만들 수 있기 때문에 바람직하지 못하다. 싱글톤(Singleton)의 생성방법&lt;span style=”font-size:110%”; font-weight:normal&gt;싱글톤의 가장 일반적인 생성 방식은 두 가지가 있다. 두 방식 모두 생성자는private 로 감춰두고, 인스턴스에 접근할 수 있는 유일한 수단으로 public static 맴버를 하나 마련해 둔다. 1. public static 맴버가 final 필드인 방식 12345678public class Singleton1{ // public static final 맴버 public static final Singleton1 s1 = new Singleton1(); // private 생성자 private Singleton1() { } public void doSomething1() { }} 실행문 123456789public class MainSingleton { public static void main(String[] args) { // public static 맴버가 final 필드인 방식의 Singleton Singleton1 chk1_s1 = Singleton1.s1; Singleton1 chk2_s1 = Singleton1.s1; // 둘이 주소값이 같은지 확인 System.out.println(chk1_s1 == chk2_s1); }} 결과 1true 2. 정적 팩터리 메서드를 public static 맴버로 제공하는 방식 12345678910public class Singleton2 { // public static final 맴버 public static final Singleton2 s2 = new Singleton2(); // private 생성자 private Singleton2() { } // 정적 팩토리 메서드 public static Singleton2 getInstance(){ return s2; } public void doSomething2() { }} 실행문 123456789public class MainSingleton { public static void main(String[] args) { // 정적 팩터리 메서드를 public static 멤버로 제공하는 방식의 Singleton Singleton2 chk1_s2 = Singleton2.getInstance(); Singleton2 chk2_s2 = Singleton2.getInstance(); // 둘이 주소값이 같은지 확인 System.out.println(chk1_s2 == chk2_s2); }} 결과 1true public static 맴버가 final 필드인 방식의 장점 1. 해당 클래스가 싱글턴임이 API에 명확히 드러난다. 2. 간결하다. 정적 팩터리 메서드를 public static 맴버로 제공하는 방식의 장점 1. getInstance() 메서드는 항상 같은 객체의 참조를 반환하므로, 다른 인스턴스는 만들어 지지 않는다. 2. API를 바꾸지 않고도 싱글턴이 아니게 바꿀 수 있다.(getInstance() 에서 리턴하는 값을 바꾸면 된다.) 3. 정적 팩터리 메서드를 제너릭 싱글턴 팩터리로 만들 수 있다.(아이템 30) 4. 정적 팩터리 메서드 참조를 Supplier로 사용할 수 있다.(호출한 곳으로 데이터를 리턴하는 역활을 한다.) 하지만!!! 이 두 방식에는 치명적인 단점이 존재한다. 만약 이 방법들을 직렬화에 사용한다면, 역직력화 할 때 새로운 인스턴스가 생겨서 싱글턴이 아니게 되어 버린다. 이것을 해결하려면 모든 인스턴스 필드를 직렬화 대상에서 제외(transient)한다 선언하고, readResolve 메서드를 제공해야 한다.","link":"/2022/05/25/%EC%8B%B1%EA%B8%80%ED%86%A4(Singleton)/"},{"title":"알고리즘 및 빅오 표기법","text":"알고리즘이란? 어떤 문제가 주어졌을 때, 문제를 풀기 위한 동작들의 절차 예) 집에서 학교가는법, 일어서는법, 라면끓이는 법 등등…. Input값을 통해 Output 결과를 내는 과정 빅오 표기법 점근 표기법의 종류중 한 개 이다. 복잡도를 이야기 할 때 가장 기본이 되는 상한 점근 방식이다. 여러가지 알고리즘 방법들을 시간과 공간 측면에서 비교할 수 있게 도와준다. 공간복잡도 데이터 관리에 필요한 공간 데이터 양의 변화에 따른 공간 변화 예상 소요 공간 측정 시간복잡도 데이터 처리에 소요되는 시간 데이터 양의 변화에 따른 소요 시간의 변화 예상 처리 시간을 측정한다. 지연 장애가 발생했을 때 왜 발생했는지를 찾을 수 있는 근거가 된다. O(1) 입력 데이터의 크기와 상관 없이 항상 일정한 시간이 걸리는 알고리즘 배열의 Random Access, Hash O(N) 입력 데이터의 크기에 비례해서 시간이 소요되는 알고리즘 for문 123for(int i = 0; i &lt; N; i++) { .....} O(N2) 입력 데이터의 제곱에 비례해서 시간이 소요되는 알고리즘 2중 for문 12345for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; N; j++){ ..... }} O(logN) 이진탐색(Binary Search) 검색할 배열의 중간값을 가지고 찾고싶은 숫자의 값이 배열이 중간값보다 큰지 작은지 비교후 크면 오른쪽을, 작으면 왼쪽을 부분배열로 나눠서 또 다시 중간값을 가져와서 비교 후 수를 찾는 알고리즘 O(NlogN) Merge sort 주어진 데이터의 집합에서 절반씩 나누면서 하나씩 값을 비교해 가면서 다시 정렬을 해 나가면서 데이터의 N번만큼 값을 비교해 나가는 알고리즘","link":"/2022/04/11/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC%20%EB%B9%85%EC%98%A4%20%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"title":"연결 리스트(LinkedList)","text":"연결 리스트(LinkedList)선형으로 자료를 관리, 자료가 추가될 때마다 메모리를 할당 받고, 자료는 링크로 연결된다.자료의 물리적 위치와 논리적 위치가 다를 수 있다.자료를 조종하는 시간은 적다.자료의 위치 엘리먼트를 찾는 시간은 길다. LinkedList의 장점 배열의 복사나 재할당없이 데이터가 추가 가능하다. 자신이 쓰는 공간만 늘어났다 줄었다 할 수 있어 유연한 공간 활용이 가능하다. LinkedList의 단점 Random Access 가 불가능해서 데이터 접근에 대한 시간이 늘어난다. LinkedList의 특징 LinkedList는 Node 라는 객체로 구성되어 있다. Node는 두가지 요소로 구성되어 있다. Data를 저장할 수 있는 Field 다음 Node를 가리킬수 있는 Next Pointer Field 이 Node들이 연결되있는 형태를 LinkedList 라고 부른다. LinkedList에서 가장 앞에 위치하고 있는 Node를 Head,가장 끝에 위치한 Node를 Tail 이라고 한다. LinkedList의 검색 (Search) Index를 통한 Random Access 가 불가능하다. 자신을 가리키고 있는 Next Pointer 만을 통해 접근가능. 그래서 LinkedList는 검색할 때 처음(Head)에서 부터 끝(Tail)까지 순회를 하면서 검색을 한다. 시간 복잡도는 O(N) LinkedList의 추가 (Add) 끝(Tail) Node의 뒤에 붙히는걸 기본값으로 한다. 검색과 마찬가지로 앞에서 부터 하나씩 찾아가면서 제일 끝 Node에 간 다음,Null을 가리키고 있는 Pointer에 추가하고자 하는 Node Data를 넣어줘야 한다. 시간 복잡도는 O(N) LinkedList의 삽입 (Insert) ArrayList와 다르게 Data를 다 밀어줄 필요가 없이 간단하게 Pointer만 바꿔주면 삽입된다. 이전 Node의 Next Pointer가 삽입할 Node를 가리키게 한 다음삽입할 Node의 Next Pointer는 이전 Node가 원래 가리키고 있던 Node로 설정해주면 된다. 시간 복잡도는 O(N) 맨 앞으로 삽입하는 경우 O(1) LinkedList의 삭제 (Delete) 삽입과 마찬가지로 간단하게 Pointer만 바꿔주면 삭제된다. 이전 Node의 Next Pointer가 삭제할 Node의 Next Pointer가 가리키고 있던 Node로 바꿔준다. 그러면 아무것도 참조하지 않는 Node를 garbage collector가 수거 해 가면서 자동으로 삭제가 된다. 시간 복잡도는 O(1)","link":"/2022/04/25/%EC%97%B0%EA%B2%B0%20%EB%A6%AC%EC%8A%A4%ED%8A%B8(LinkedList)/"},{"title":"열거 함수(enum)","text":"열거 타입(enum)이란? 몇가지 상수의 집합을 정의하는 한정된 값만을 갖는 데이터 타입으로, 집합이 갖는 값이 한정되어 있고, 다른 값을 허용하지 않는 경우에 사용한다. 예) 성별 : 남성, 여성요일 : 월, 화, 수, 목, 금, 토, 일계절 : 봄, 여름, 가을, 겨울 열거 타입(enum)의 장점 1. 열거체를 비교할 때 실제 값 뿐만 아니라 타입까지 체크해 준다. 2. 열거체의 상숫값이 재정의되더라도, 다시 컴파일할 필요가 없어진다. 열거 타입(enum) 선언 방법 Intellij 기준으로 New -> Java Class -> Enum 을 선택하여 클래스를 생성 할 수 있다. 일단 예를 들어서 계절 열거체를 만들어 보자. 먼저 열거체 이름(Season)을 지정해 주고, 열거 상수를 선언해 주자. 1234567public enum Season { // 열거 상수 선언 SPRING, SUMMER, AUTUMN, WINTER} 열거 상수는 모두 대문자로 작성한다. 만약 열거 상수가 여러 단어로 구성되어 있다면, 단어 사이를 밑줄(_)로 연결하는 것이 관례이다. 예) 12345public enum LoginResult{ // 열거 상수 LOGIN_SUCCESS, LOGIN_FAILED} 선언된 열거 타입(enum) 사용 방법 이렇게 선언된 열거체를 사용하는 방법은 다음과 같다 123456789101112131415public class SeasonEnum { public static void main(String[] args) { // 열거 타입으로 변수(season2022) 선언 후, 열거 상수 값 할당해주기. // 열거 상수는 단독으로 사용 할 수 없어, 앞에 열거타입이 붙어야 한다. Season season2022 = Season.SPRING; // 이렇게 출력해보면 SPRING 이 출력된다. System.out.println(season2022); // 그리고 열거 타입 변수도 참조 타입이기 때문에, null 값을 저장 할 수 있다. season2022 = null; // 이렇게 출력하보면 null 이 출력된다. System.out.println(season2022); }} new 연산자로는 열거타입을 생성할 수 없고, 열거변수를 선언하여 열거상수 값을 할당시켜줘야 한다. 열거타입 변수에 저장되는 값은 참조변수로, Stack 영역에 주소 값이 생성된다. 이 때 열거타입 변수의 주소값과 열거상수의 주소값은 같은 영역을 참조하기 때문에 동일한 값을 가진다.","link":"/2022/05/23/%EC%97%B4%EA%B1%B0%20%ED%95%A8%EC%88%98(enum)/"},{"title":"자료구조","text":"자료구조란? 프로그램에서 사용할 많은 데이터를 메모리상에서 관리하는 여러 구현방법들이다. 효율적인 자료구조가 성능 좋은 알고리즘의 기반이 된다. 자료의 효율적인 관리는 프로그램의 수행속도와 밀접한 관련이 있다. 여러 자료 구조 중에서 구현하려는 프로그램에 맞는 최적의 자료구조를 활용해야 하므로 자료구조에 대한 이해가 중요하다. 자료구조의 종류 배열(Array) : 선형으로 자료를 관리, 정해진 크기의 메모리를 먼저 할당받아 사용하고, 자료의 물리적 위치와 논리적 위치가 같다. 연결 리스트(LinkedList) : 선형으로 자료를 관리, 자료가 추가될 때 마다 메모리를 할당 받고, 자료는 링크로 연결된다. 자료의 물리적 위치와 논리적 위치가 다를 수도 있다. 스택(Stack) : 나중에 입력된 자료가 가장 먼저 출력되는 LIFO 자료구조이다. (후입선출) 큐(Queue) : 가장 먼저 입력 된 자료가 가장 먼저 출력되는 FIFO 자료구조이다. (선입선출) 힙(Heap) : 우선 큐 를 구현해 놓은 것이다. (Priority queue) Max heap : 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는 경우 Min heap : 부모 노드는 자식 노드보다 항상 작거나 같은 값을 갖는 경우 힙 정렬에 활용 할 수 있다. 트리(Tree) : 부모 노드와 자식 노드간의 연결로 이루어진 자료 구조 이진 트리(Binary Tree) : 부모 노드에 자식 노드가 두개 이하인 트리 이진 검색 트리(Binary Search Tree) : 자료의 중복을 허용하지 않으면서 왼쪽 자식 노드는 부모 노드보다 작은 값, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가진 트리 그래프(Graph) : 정점과 간선들의 유한 집합인 자료 구조 해싱(Hashing) : 키(key)에 대한 자료를 검색하기 위한 자료 구조.","link":"/2022/04/22/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"title":"인스턴스 및 생성자","text":"메서드 (method) 객체의 기능을 구현하기 위해 클래스 내부에 구현되는 함수 맴버 변수를 이용하여 클래스의 기능을 구현한 함수 메서드의 이름은 그 객체를 사용하는 객체에 맞게 짓는것이 좋음 인스턴스 (instance) 클래스명 참조변수명 = new 클래스명(); 클래스는 객체의 속성을 정의 하고, 기능을 구현하여 만들어 놓은 코드 상태이다. 실제 클래스 기반으로 생성된 객체(인스턴스)는 각각 다른 맴버 변수 값을 가지게 된다. new 키워드를 사용하여 인스턴스 생성. 생성자 (constructor) 생성자 선언: 접근제어지시자 클래스명(매개변수) {} 객체를 생성할 때 new 키워드와 함께 사용 생성자는 매개변수가 없는 기본 생성자와 매개변수를 여러개 받는 생성자를 만들 수 있다. 생성자는 일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new 와 함께 호출됨. 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출함. 생성자는 반환 값이 없고, 클래스의 이름과 동일하다. 대부분의 생성자는 외부에서 접근이 가능하지만, 필요에 의해 private로 선언되는 경우가 있다. 기본 생성자 (default constructor) 클래스에는 반드시 하나 이상의 생성자가 존재해야 한다. 클래스에 생성자를 구현하지 않아도 new 키워드와 함께 생성자를 호출 가능하다. 클래스에서 생성자가 하나도 없는 경우 컴파일러에서 생성자 코드를 넣어준다.","link":"/2022/04/14/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%20%EB%B0%8F%20%EC%83%9D%EC%84%B1%EC%9E%90/"},{"title":"접근제어 지시자와 정보 은닉","text":"접근 제어 지시자 클래스 외부에서 클래스의 맴버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드. private : 같은 클래스 내부에서만 접근 가능(외부 클래스, 상속 관계의 클래스에서도 접근 불가) 아무것도 없음(default) : 같은 패키지 내부에서만 접근 가능(상속 관계라도 패키지가 다르면 접근 불가) protected : 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근할 수 없음 public : 클래스의 외부 어디서나 접근할 수 있음 get()/set() 메서드private으로 선언된 맴버 변수(필드)에 대해접근. this this는 인스턴스 자신의 메모리를 가리킨다 생성자에게 또 다른 생성자를 호출 할때 사용 자신의 주소(참조값)을 반환함 static static변수 여러 인스턴스가 공유하는 기준 값이 필요한 경우 공통으로 사용하는 변수가 필요한 경우 학생마다 새로운 학번 생성 카드회사에서 카드를 새로 발급할때마다 새로운 카드 번호를 부여 회사에 사원이 입사할때 마다 새로운 사번이 필요할때 static변수는 인스턴스를 생성하지 않고도 클래스 이름으로 참조해 출력 가능하다. static 메서드 static 메서드 안에서는 인스턴스 변수(일반 맴버 변수)를 사용할 수 없다 왜냐하면 일반 맴버 변수가 메모리에 생성이 안된 상태일수도 있기 때문이다. 싱글톤 패턴 싱글톤 패턴이란 인스턴스가 단 한개만 생성되어야 하는 경우 사용하는 디자인 패턴이다. static변수, 메서드를 활용하여 구현 할 수 있다","link":"/2022/04/13/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4%20%EC%A7%80%EC%8B%9C%EC%9E%90%EC%99%80%20%EC%A0%95%EB%B3%B4%20%EC%9D%80%EB%8B%89/"},{"title":"정렬(sort)","text":"정렬 (sort) 정렬은 크게 두가지인 안정(Stable) 정렬과 불안정(unStable) 정렬로 나눌 수 있다. 버블 정렬 (Bubble Sort) 인접한 두 Element의 값을 비교 두 값이 정렬되어 있지 않다면 위치를 교환한다. 정렬의 완료된 Elements를 제외하고 위의 과정을 반복한다. 시간복잡도 평균: O(N2) 직관적이고 단순한 알고리즘이다. 삽입 정렬 (Insert Sort) 리스트의 앞에서 부터 이미 정렬된 서브리스트의 값들과 비교하고 자신의 위치에 삽입한다. 삽입정렬의 특징 안정정렬이다. 단순한 알고리즘이다. 데이터의 이동이 많다. 하지만 리스트 내의 데이터가 어느정도 정렬이 되어 있는 경우 데이터의 이동이 적어진다. 시간복잡도 평균: O(N2) 모두 정렬이 되어 있는 경우: O(N) 모두 역으로 정렬되어 있는 경우: O(N2) 합병 정렬 (Merge Sort) 하나의 리스트를 두개의 균등한 크기의 리스트로 분할하고 부분 리스트를 합치면서 정렬하여 전체가 정렬되게 하는 방법 분할정복 (Divide and Conquer) 알고리즘 시간복잡도 O(NlogN) 퀵 정렬 (Quick Sort) 추가적인 메모리 공간을 사용하지 않는다 불안정한 정렬이다 Divide and Conquer 시간복잡도 평균: O(NlogN) 정렬된 리스트(최악): O(N2) 하지만 실제보다 더 짧은 시간이 소요된다.(참조 지역성) 한번 결정된 pivot 값은 이후의 연산에서 제외한다. 처음에 pivot 값을 설정한 후 pivot 값을 기준으로 배열을 재배치를 하기 시작한다.(Pivot보다 작은값, Pivot보다 큰값) 그리고 재배치된 배열을 또 다시 Pivot값을 정해서 재배치한다.(무한반복)","link":"/2022/05/02/%EC%A0%95%EB%A0%AC(sort)/"},{"title":"제네릭 자료형 및 제너릭 메서드 정의","text":"제네릭 자료형 정의 클래스에서 사용하는 변수의 자료형이 여러개 일 수 있고, 그 기능(메서드)은 동일한 경우클래스의 자료형을 특정하지 않고 추후 해당 클래스를 사용할 때 지정 할 수 있도록 선언해준다. 자료형의 변환은 컴파일러에 의해 검증되므로 안정적인 프로그래밍 방식이다. 컬렉션 프레임워크에서 많이 사용되고있다. 다이아몬드 연산자 &lt;&gt; 다이아몬드 연산자 내부에서 자료형은 생략 가능함. 하지만 T라는 위치에 어느 자료형이라도 넣을수 있지만 이러면 문제가 생길 수 있기 때문에 &lt;T extends 클래스&gt; 를 사용해야 한다. T 자료형의 범위를 제한 할 수 있다. 상위 클래스에서 선언하거나 정의하는 메서드를 활용할 수 있다. 상속을 받지 않는 경우 T는 Object로 변환하여 Object클래스가 기본으로 제공하는 메서드만 사용 가능하다. 제너릭 메서드 자료형 매개변수를 매서드의 매개변수나 반환 값으로 가지는 메서드는 자료형 매개 변수가 하나 이상인 경우도 있음 제네릭 클래스가 아니여도 내부에 제네릭 메서드는 구현하여 사용 할 수 있다. 사용법↓public &lt;자료형 매개 변수&gt; 반환형 메서드이름(자료형 매개변수)","link":"/2022/04/30/%EC%A0%9C%EB%84%A4%EB%A6%AD%20%EC%9E%90%EB%A3%8C%ED%98%95%20%EB%B0%8F%20%EC%A0%9C%EB%84%88%EB%A6%AD%20%EB%A9%94%EC%84%9C%EB%93%9C%20%EC%A0%95%EC%9D%98/"},{"title":"커밋 컨벤션 정리","text":"Commit Message Convention커밋 컨벤션을 쓰는 이유 팀원들과 커뮤니케이션을 원활하게 하기 위해서 일관성있게 각 커밋의 위치에서 무엇을 했나 한눈에 확인하기 위해 시각적 통일성을 확보하기 위해서 해당 커밋에 대한 어떤 내용이 이루어졌는지 파악하기 위해서 과거 코드에 대한 코드 추적을 원활하게 하기 위해서 커밋 컨벤션 정리 Commit frefix 용도 feat: 내용 새로운 기능을 추가할 경우 docs: 내용 문서파일을 생성하거나 수정한 경우 conf: 내용 설정파일을 생성하거나 수정한 경우 test: 내용 테스트를 추가, 리펙토링 했을경우 fix: 내용 올바르지 않은 동작을 고친 경우 refactor: 내용 동작을 더 괜찮게 고쳤을 경우 ci: 내용 CI 관련 설정을 수정한 경우 build: 내용 빌드 관련 파일을 수정한경우 perf: 내용 성능을 향상시키는 코드로 변경한경우","link":"/2022/04/10/%EC%BB%A4%EB%B0%8B%20%EC%BB%A8%EB%B2%A4%EC%85%98%20%EC%A0%95%EB%A6%AC/"},{"title":"컴퓨터의 자료 표현 방법","text":"컴퓨터는 0과 1로만 데이터를 저장한다. 1bit 는 컴퓨터가 표현하는 데이터의 최소 단위로 2진수 하나의 값을 저장할 수 있는 메모리의 크기이다. 1byte는 8bit 다. 진수 표현 16진수 2 4 8 A 10진수 2 4 8 10 8진수 2 4 10 12 2진수 0010 0100 1000 1010 8bit(1byte)로 5를 표현하면0 0 0 0 0 1 0 1 ↑ 맨 첫번째 비트는 부호비트(MSB)이다. 비트로 나타낼 수 있는 수의 개수는 2 ^ N개의 비트 비트로 나타낼 수 있는 수의 범위는 2 ^ N개의 비트 - 1 Java에서 각종 진수 표현하기 진수 변수 초기화 값 2진수 0B 8진수 0 16진수 0X 예) 결과)","link":"/2022/04/06/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98%20%EC%9E%90%EB%A3%8C%20%ED%91%9C%ED%98%84%20%EB%B0%A9%EB%B2%95/"},{"title":"컬렉션 프레임워크","text":"컬렉션 프레임워크 프로그램 구현에 필요한 자료구조를 구현해 놓은 JDK 라이브러리 java.util 패키지에 구현되어 있다. 개발에 소요되는 시간을 절약하면서 최적화 된 알고리즘을 사용할 수 있다. 여러 구형 클래스와 인터페이스의 활용에 대한 이해가 필요하다. Collection은 하나의 요소를 관리하는데 사용된다. 하위에 List와 Set이 있다.List(ArrayList, Vector, LinkedList 등등)는 순서에 기반한 배열을 관리하는데 사용되고 중복을 허용한다. Set(HashSet, TreeSet)은 집합인데 중복을 허용하지 않으니 유일한 값(학번, 주민번호 등등)을 관리할때 사용한다. HashSet은 검색을 하기위한 알고리즘이기 때문에 순서와 상관이 없다. Set의 값을 꺼낼때는 Iterator 함수를 사용해야 한다. 앞에 Tree가 붙혀진 라이브러리(TreeSet, TreeMap)는 내부적으로 바이너리서치트리가 구현되어있다. TreeSet은 객체의 정렬에 사용하는 클래스이다. Set 인터페이스를 구현하여 중복을 허용하지 않고, 오름차순이나 내림차순으로 객체를 정렬할 수 있음. 바이너리서치트리에 저장하기 위해 각 객체를 비교해야 한다. 비교 대상이 되는 객체에 Comparable이나 Comparator 인터페이스를 구현해야 TreeSet에 추가 될 수 있다. Map은 Key, Value Pair를 동시에 관리하기 위해 사용된다. Key값은 유일해서 중복을 허용하지 않는다. TreeMap은 Key가 정렬이 된다. 일반적으로 HashMap을 많이 쓴다. HashMap은 가장 많이 사용되는 Map 인터페이스 기반 클래스이다. key - value를 쌍으로 관리하는 메서드를 구현한다. key를 이용하여 값을 저장하고 key를 이용하여 값을 꺼내오는 방식. key가 되는 객체는 중복될 수 없고 객체의 유일성을 비교를 위한 equals()와 hashCode() 메서드들 구현해야 함.","link":"/2022/05/01/%EC%BB%AC%EB%A0%89%EC%85%98%20%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"title":"큐(Queue)","text":"큐(Queue) JDK클래스 : ArrayList Queue의 특징 선입선출(FIFO - First In First Out) 순서가 보장되는 처리 방식이다. 맨앞에서 자료를 꺼내거나 삭제하고, 맨 뒤에서 자료를 추가할때 사용함. 순차적으로 입력된 자료를 순서대로 처리하는데 많이 사용되는 구조 콜센터에서 들어온 문의전화, 사용자가 몰린 서버, 메세지 큐 등에 활용된다. Data가 입력되는 동작을 Enqueue Data가 빠지는 동작을 Dequeue Data가 들어갈때는 제일 뒷쪽인 rear 쪽으로 data가 들어간다. Data가 빠질때는 제일 앞쪽인 front 쪽으로 data가 빠진다. 배열 형태로 구현하면 Data를 뺄때마다 나머지 Data를 옮겨줘야 하기 때문에 매우 비효율적이다. Queue에서의 중요한 연산 push(), offer(), add() data를 넣는 작업 pop(), poll() data를 빼오는 작업 peek() data를 확인하는 작업","link":"/2022/04/27/%ED%81%90(Queue)/"},{"title":"해싱(hashing)","text":"해싱 (Hashing) 자료를 검색하기 위한 자료구조 데이터를 빠르게 저장하고 가져오는 기법 중 하나 키(key)에 대한 자료를 검색하기 위한 사전개념의 자료 구조 키(Key)에 특정 연산을 적용하여 테이블의 주소를 계산한다. key는 유일하고 이에 대한 value를 쌍으로 저장해준다. index = h(key) 해시 함수가 key에 대한 인덱스를 반환해줌.해당 인덱스 위치에 자료를 저장하거나 검색하게 됨. 해시 함수에 의해 인덱스 연산이 산술적으로 가능하다. 저장되는 메모리 구조를 해시테이블이라 한다. jdk클래스 : HashMap, Properties 해시 테이블 (Hash Table) 순서없이 (Key, Value)쌍을 저장한다. Value 는 Key를 기준으로 관리된다. 따라서 Key는 고유한 값을 가진다.(중복 X) 해시 함수 (Hash Function) 임의의 데이터(Key)를 특정값(해시값)으로 매핑시키는 함수 좋은 해시 함수 키 값을 고르게 분포시킨다 빠른 계산이 가능하다 충돌을 최소화시킨다 충돌이란 키 값이 다른데, 해시 함수의 결과값이 같은 경우를 말한다. 해시 충돌 (Hash Collision) 키값이 다른데, 해시 함수의 결과값이 동일한 경우 해시 충돌 해결 방법 체이닝 방법 중복값이 나오면 새로운 Node를 연결하는 방법 Open Addressing 방법 충돌 발생 시 다른 버킷에 데이터를 저장하는것 선형탐색 해시 충돌 시 n칸을 건너뛴 다음 버킷에 저장 제곱탐색 N2칸(1,4,9,16…)을 건너뛴 버킷에 데이터를 저장 하지만 처음 해시 값이 같다면 문제발생 이중해시 해시 값에 다른 해시 함수를 한번 더 적용 Hashfunction1(): 최초의 해시 값을 구함 Hashfunction2(): 충돌 발생시 이동 폭을 구함 최초의 해시 값이 같더라도 이동 폭이 다르기 때문에 clustering 문제 해결 가능","link":"/2022/04/29/%ED%95%B4%EC%8B%B1(hashing)/"},{"title":"힙(heap), 트리(Tree)","text":"힙(heap) Priority queue를 구현(우선 큐) Max heap : 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는 경우 Min heap : 부모 노드는 자식 노드보다 항상 작거나 같은 값을 가지는 경우heap 정렬에 활용할 수 있음 트리(Tree) : 부모 노드와 자식 노드간의 연결로 이루어진 자료 구조 이진트리(binary tree) : 부모노드에 자식노드가 두개 이하인 트리 heap sort : 큰 수부터 밖으로 꺼내지는것 이진 검색 트리(binary search tree) 검색을 목적으로 만들어진 트리. 자료(key)의 중복이 허용되지 않는다. 왼쪽 자식 노드는 부모 노드보다 작은 값, 오른쪽 자식 노드는 부모 노드보다 큰 값을 가진다. 자료 검색에 걸리는 시간은 평균 log(n)이다 inorder traversal 탐색을 하게 되면 자료가 정렬되어 출력된다.","link":"/2022/04/28/%ED%9E%99(heap),%20%ED%8A%B8%EB%A6%AC(Tree)/"}],"tags":[{"name":"Class 클래스","slug":"Class-클래스","link":"/tags/Class-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Filter 및 Interceptor","slug":"Filter-및-Interceptor","link":"/tags/Filter-%EB%B0%8F-Interceptor/"},{"name":"Git Bash 명령어","slug":"Git-Bash-명령어","link":"/tags/Git-Bash-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"Java의 역사","slug":"Java의-역사","link":"/tags/Java%EC%9D%98-%EC%97%AD%EC%82%AC/"},{"name":"Java의 특징","slug":"Java의-특징","link":"/tags/Java%EC%9D%98-%ED%8A%B9%EC%A7%95/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Object 클래스","slug":"Object-클래스","link":"/tags/Object-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"POJO(Plain Old Java Object) JAVA","slug":"POJO-Plain-Old-Java-Object-JAVA","link":"/tags/POJO-Plain-Old-Java-Object-JAVA/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"String, StringBuilder, StringBuffer 클래스","slug":"String-StringBuilder-StringBuffer-클래스","link":"/tags/String-StringBuilder-StringBuffer-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"Springboot에서 springfox(Swagger) 에러해결법","slug":"Springboot에서-springfox-Swagger-에러해결법","link":"/tags/Springboot%EC%97%90%EC%84%9C-springfox-Swagger-%EC%97%90%EB%9F%AC%ED%95%B4%EA%B2%B0%EB%B2%95/"},{"name":"release version ?? not supported","slug":"release-version-not-supported","link":"/tags/release-version-not-supported/"},{"name":"객체지향 프로그래밍","slug":"객체지향-프로그래밍","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"객체지향 언어","slug":"객체지향-언어","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%96%B8%EC%96%B4/"},{"name":"객체와 클래스","slug":"객체와-클래스","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"객체지향 설계 5원칙(SOLID)","slug":"객체지향-설계-5원칙-SOLID","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-SOLID/"},{"name":"내부 클래스","slug":"내부-클래스","link":"/tags/%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"다형성","slug":"다형성","link":"/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"더블 연결 리스트(DoubleLinkedList)","slug":"더블-연결-리스트-DoubleLinkedList","link":"/tags/%EB%8D%94%EB%B8%94-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-DoubleLinkedList/"},{"name":"디자인 패턴","slug":"디자인-패턴","link":"/tags/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"},{"name":"자료구조","slug":"자료구조","link":"/tags/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"메서드","slug":"메서드","link":"/tags/%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"빌더(Builder)패턴","slug":"빌더-Builder-패턴","link":"/tags/%EB%B9%8C%EB%8D%94-Builder-%ED%8C%A8%ED%84%B4/"},{"name":"상속","slug":"상속","link":"/tags/%EC%83%81%EC%86%8D/"},{"name":"스택(Stack)","slug":"스택-Stack","link":"/tags/%EC%8A%A4%ED%83%9D-Stack/"},{"name":"싱글톤(Singleton)","slug":"싱글톤-Singleton","link":"/tags/%EC%8B%B1%EA%B8%80%ED%86%A4-Singleton/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"연결 리스트(LinkedList)","slug":"연결-리스트-LinkedList","link":"/tags/%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-LinkedList/"},{"name":"열거 함수(enum)","slug":"열거-함수-enum","link":"/tags/%EC%97%B4%EA%B1%B0-%ED%95%A8%EC%88%98-enum/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"},{"name":"생성자","slug":"생성자","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"접근제어 지시자","slug":"접근제어-지시자","link":"/tags/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4-%EC%A7%80%EC%8B%9C%EC%9E%90/"},{"name":"정보 은닉","slug":"정보-은닉","link":"/tags/%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89/"},{"name":"정렬(sort)","slug":"정렬-sort","link":"/tags/%EC%A0%95%EB%A0%AC-sort/"},{"name":"제네릭 자료형 및 제너릭 메서드 정의","slug":"제네릭-자료형-및-제너릭-메서드-정의","link":"/tags/%EC%A0%9C%EB%84%A4%EB%A6%AD-%EC%9E%90%EB%A3%8C%ED%98%95-%EB%B0%8F-%EC%A0%9C%EB%84%88%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98/"},{"name":"커밋 컨벤션","slug":"커밋-컨벤션","link":"/tags/%EC%BB%A4%EB%B0%8B-%EC%BB%A8%EB%B2%A4%EC%85%98/"},{"name":"Commit Convention","slug":"Commit-Convention","link":"/tags/Commit-Convention/"},{"name":"컴퓨터의 자료 표현 방법","slug":"컴퓨터의-자료-표현-방법","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9E%90%EB%A3%8C-%ED%91%9C%ED%98%84-%EB%B0%A9%EB%B2%95/"},{"name":"컬렉션 프레임워크","slug":"컬렉션-프레임워크","link":"/tags/%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/"},{"name":"큐(Queue)","slug":"큐-Queue","link":"/tags/%ED%81%90-Queue/"},{"name":"해싱(hashing)","slug":"해싱-hashing","link":"/tags/%ED%95%B4%EC%8B%B1-hashing/"},{"name":"힙(heap), 트리(Tree)","slug":"힙-heap-트리-Tree","link":"/tags/%ED%9E%99-heap-%ED%8A%B8%EB%A6%AC-Tree/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"HTTP","slug":"Programming/HTTP","link":"/categories/Programming/HTTP/"},{"name":"Java","slug":"Programming/Java","link":"/categories/Programming/Java/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Git Bash 명령어","slug":"Git/Git-Bash-명령어","link":"/categories/Git/Git-Bash-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"클래스","slug":"Programming/Java/클래스","link":"/categories/Programming/Java/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"IDE","slug":"Programming/Java/IDE","link":"/categories/Programming/Java/IDE/"},{"name":"객체지향","slug":"Programming/Java/객체지향","link":"/categories/Programming/Java/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"Linux 명령어","slug":"Git/Linux-명령어","link":"/categories/Git/Linux-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"내부 클래스","slug":"Programming/Java/내부-클래스","link":"/categories/Programming/Java/%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"다형성","slug":"Programming/Java/다형성","link":"/categories/Programming/Java/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"Spring","slug":"Programming/Java/Spring","link":"/categories/Programming/Java/Spring/"},{"name":"Algorithm","slug":"Programming/Algorithm","link":"/categories/Programming/Algorithm/"},{"name":"디자인 패턴","slug":"Programming/디자인-패턴","link":"/categories/Programming/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"},{"name":"Markdown 문법 정리","slug":"Markdown/Markdown-문법-정리","link":"/categories/Markdown/Markdown-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/"},{"name":"메서드 및 메서드의 종류","slug":"Programming/Java/메서드-및-메서드의-종류","link":"/categories/Programming/Java/%EB%A9%94%EC%84%9C%EB%93%9C-%EB%B0%8F-%EB%A9%94%EC%84%9C%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A5%98/"},{"name":"상속","slug":"Programming/Java/상속","link":"/categories/Programming/Java/%EC%83%81%EC%86%8D/"},{"name":"열거 함수(enum)","slug":"Programming/Java/열거-함수-enum","link":"/categories/Programming/Java/%EC%97%B4%EA%B1%B0-%ED%95%A8%EC%88%98-enum/"},{"name":"인스턴스 및 생성자","slug":"Programming/Java/인스턴스-및-생성자","link":"/categories/Programming/Java/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%B0%8F-%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"접근제어 지시자","slug":"Programming/Java/접근제어-지시자","link":"/categories/Programming/Java/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4-%EC%A7%80%EC%8B%9C%EC%9E%90/"},{"name":"커밋 컨벤션","slug":"Git/커밋-컨벤션","link":"/categories/Git/%EC%BB%A4%EB%B0%8B-%EC%BB%A8%EB%B2%A4%EC%85%98/"},{"name":"CS","slug":"Programming/CS","link":"/categories/Programming/CS/"},{"name":"Error모음","slug":"Programming/Java/IDE/Error모음","link":"/categories/Programming/Java/IDE/Error%EB%AA%A8%EC%9D%8C/"},{"name":"자료구조","slug":"Programming/Algorithm/자료구조","link":"/categories/Programming/Algorithm/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0/"},{"name":"생성 패턴","slug":"Programming/디자인-패턴/생성-패턴","link":"/categories/Programming/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/%EC%83%9D%EC%84%B1-%ED%8C%A8%ED%84%B4/"}]}