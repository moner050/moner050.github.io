{"pages":[],"posts":[{"title":"Git Bash 명령어 정리","text":"Git Bash 명령어 정리 명령어 의미 git config –global user.name “username“ git의 username 설정 git config –global user.email “email“ git의 email 설정 git config –list git의 설정값 출력 git init 새로운 local Repository 생성 git status 현재 git의 상태 확인 git clone 저장소URL 현재 디렉토리에 해당 git clone git add staging Area로 작업한 파일 add git commit local Repository로 변경사항 commit git push remote Repository로 commit한 파일 push git push origin 브랜치명 commit한 내용을 remote repository에 push git branch local branch 리스트 출력 git branch -m master main branch명을 master에서 main으로 변경 git branch 브랜치명 local branch 생성 git branch -D 브랜치명 local branch 삭제 git switch 브랜치명 local branch 이동","link":"/2022/04/09/Git%20Bash%20%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"title":"Java","text":"Java의 역사 Java는 C와 C++은 포인터로 메모리를 직접 핸들링을 해서 시스템이 다운될 확률이 높아 더 안정적인 언어가 없을까 해서 썬 마이크로시스템즈의 제임스 고슬링과 다른 연구원들이 개발한 객체 지향적 프로그래밍 언어이다. 1991년 그린프로젝트라는 이름으로 시작해서 1995년에 정식 발표했다. (Java의 초기 이름은 오크(Oak) or 그린(Green)) 최초의 Java는 C++를 약간 변형한 형태로 가전제품에 내장된 프로그램을 위한 언어로 만들어 졌지만 현재의 자바는 웹앱과 모바일 프로그램 개발까지 폭넓게 사용되고 있다. Java의 특징 WORA(Write Once Run Anywhere)가 가능해 플랫폼에 영향을 받지 않으므로 다양한 환경에서 사용가능하다. 객체지향 언어이기 때문에 유지보수가 쉽고 확장성이 좋다 프로그램이 안정적이다 풍부한 기능이 제공되는 오픈 소스이다. 소스: 프로그래밍 언어로 작성된 텍스트 파일 컴파일: 소스 파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정 바이트파일: 자바 가상 기계(JVM)에서 실행 가능한 바이너리 코드 파일 JVM(Java Virtual Machine): 각기 다른 플랫폼에서 동일한 자바 실행 환경 제공. JVM 자체는 플랫폼에 종속적이다. 객체와 클래스 객체란? 클래스의 모양 그대로 찍어낸 실체 프로그램 실행중에 생성되는 실체 메모리 공간을 갖는 구체적인 실체 인스턴스(instance)라고도 부른다. 클래스란? 객체를 만들어내기 위한 설계도 혹은 틀 객체의 속성(state)과 행동(behavior) 포함. 예) 클래스 객체 사람 나, 너, 이웃집아저씨 붕어빵틀 구워진 붕어빵 여러개 소나타 자동차 출고된 실제 소나타 20대 객체지향 프로그래밍(OOP)이란? 프로그램의 구현을 시간의 흐름순이 아닌 객체간의 관계와 협력을 기반으로 프로그래밍 하는것이다. 객체지향 프로그래밍의 장점 소프트웨어의 생산성 향상 컴퓨터 산업의 발전에 따라 소프트웨어의 생명 주기(Life Cycle)단축 소프트웨어를 빠른 속도로 생산할 필요성 증대 객체지향 언어 캡슐화, 상속, 다형성, 객체 등 소프트웨어 재사용을 위한 여러 장치가 내장되있음. 소프트웨어 재사용과 부분 수정이 빠름 소프트웨어를 다시 만드는 부담 줄어들음 소프트웨어 생산성 향상. 실세계에 대한 쉬운 모델링 컴퓨터 산업 초기때는 수학계산/통계 처리를 하는 등의 처리과정, 계산 절차가 중요했지만 현대에는 절차나 과정보다 물체(객체)들의 상호작용으로 묘사하는 것이 용이해졌기 때문 보안성 향상 객체지향의 캡슐화 특징으로 실제 구현되는 부분을 외부에서 볼 수 없으므로 정보 은닉 가능. 객체지향 프로그래밍의 단점 느린 개발속도 모든 객체의 역활과 기능을 이해해야 하기 때문에 프로그래밍에 많은 시간이 소모된다. 느린 실행속도 절차지향 프로그래밍에 비해 느린 실행속도 메모리와 연산에 대한 비용이 증가한다. 높은 난이도 절차지향 프로그래밍에 비해 난이도가 높다. 객체지향 언어(Object-oriented Language) 객체지향 언어란 프로그램을 다수의 객체로 만들고, 이 객체끼리 서로 상호작용 하도록 만드는 프로그래밍 언어이다. 여기서 객체란, 현실로 따지면 TV, 책, 냉장고, 컴퓨터, 카메라 등이 모두 객체인 것이다. 객체는 객체마다 고유한 특성과 행동을 가진다. 객체지향 언어의 특징 캡슐화 (encapsulation) 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것 외부의 접근으로 부터 객체를 보호해 준다. 데이터와 코드의 형태를 외부에서 알 수 없다. 상속 (inheritance) 상위 객체의 속성이 하위 객체에 물려지는것 하위 객체가 상위 객체의 속성을 모두 가지는 관계 Java는 클래스의 다중 상속이 불가능하다. 하지만 인터페이스 다중 상속은 가능하다. 다형성 (polymorphism) 상속과 연관된 개념으로, 같은 이름의 메소드나 클래스가 객체에 따라 다르게 동작하도록 구현한 것 다시말해, 하나의 객체가 다른 여러 객체로 재구성 되는 것이다. 오버로딩(Overloading), 오버라이딩(Overriding)이 있다. 오버로딩(Overloading): 같은 이름인 함수를 여러개 정의한 후 매개변수를 다르게 하여 각자 다르게 동작하는 것 오버라이딩(Overriding): 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현한 것 추상화 (abstraction) 객체들의 공통된 특징(기능, 속성)을 도출하는 것이다. 클래스를 정의하는 것을 추상화라고 할 수 있다.","link":"/2022/04/05/Java%EB%9E%80/"},{"title":"Linux명령어","text":"Linux는 리누즈 토발즈가 작성한 커널 혹은 GNU 프로젝트의 라이브러리와 도구가 포함된 운영체제 Kernal 하드웨어와 응용프로그램을 이어주는 운영체제의 핵심 시스템소프트웨어 Shell 운영체제의 커널과 사용자를 이어주는 소프트웨어 Linux 명령어 명령어 의미 cd 경로이동 cat 텍스트파일 내용보기 vi Vim 에디터로 열기 mkdir 디렉토리 생성 pwd 현재 경로확인 touch 텍스트형식 파일 생성 mv 파일이동 rm 파일삭제 rm -rf 디렉토리 삭제","link":"/2022/04/08/Linux%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"title":"release version 14 not supported 에러해결법","text":"Eclipse 에서 작업한 프로젝트를 Intellij에서 열어서 테스트코드를 실행해보니 이런 에러가 났다. 이것은 Java Compiler의 Project bytecode version과 Project SDK 의 버전이 맞지 않아서 그런것이다.이 에러의 해결방법을 알아보자. 일단 좌측 상단의 File -&gt; Settings 로 들어가보자. (Ctrl + Alt + S) 그리고 Build, Execution, Deployment -&gt; Compiler -&gt; Java Compiler 로 들어가서 Project bytecode version에서 JAVAC의 버전을 설정해주자. (필자는 11버전) 여기서 이제 테스트코드를 돌렸는데도 에러가 뜨면 아래 내용을 따라해보자. Intellij 좌측 상단의 File -&gt; Project Structure… 를 클릭한다. (Ctrl + Alt + Shift + S) 그리고 Project Settings -&gt; Project 에서 Project SDK 를 설정하는 곳에 자신의 JDK버전을 선택 후 Apply 후 OK 를 클릭한다. 필자는 Project bytecode version 을 JDK 11 로 설정했으니 11버전 선택 만약 목록에 없다면 Add SDK -&gt; JDK 를 클릭 후 자신의 JDK 경로를 설정후 OK -&gt; OK (필자는 C:\\Program Files\\Java\\jdk-11.0.12 였다.) 그러면 이렇게 테스트코드가 잘 실행된다.","link":"/2022/04/07/release%20version%2014%20not%20supported/"},{"title":"Markdown 문법 정리","text":"마크다운(Markdown) 문법 정리목차 띄어쓰기(여러번) 줄바꿈 제목 강조 구분선 인용구 목록(리스트) 코드블럭 링크 이미지 테이블(표) 주석 윗/아랫첨자 제목(Header) &lt;h1&gt; ~ &lt;h6&gt; 까지 제목을 표현할 수 있다.# ~ ###### 예시 123456# 제목1## 제목2### 제목3#### 제목4##### 제목5###### 제목6 ↓결과 제목1제목2제목3제목4제목5제목6 띄어쓰기(여러번) Markdown은 띄어쓰기를 여러번 입력해도 하나로 인식해버린다.그래서 띄어쓰기를 여러번 할 수 있는 방법이 두가지 있다. 1. 공백 특수문자 사용하기 ( &amp;nbsp; 또는 &amp;#160; )예시 1여러번&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;띄어쓰기를&amp;#160;&amp;#160;&amp;#160;&amp;#160;하고싶다 ↓결과 여러번&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;띄어쓰기를&amp;#160;&amp;#160;&amp;#160;&amp;#160;하고싶다(블로그 테마를 바꾸니까 이 방식으로 띄어쓰기가 되지 않는다……) 2. 전각문자로 띄어쓰기전각 문자는 한국어 키보드로는 입력이 불가능하고 일본어나 중국어 키보드일때만 입력이 가능하다. 전각문자 공백 : ( )괄호안에 있는 문자를 복사해서 사용 가능하다. 예시 1전각문자로 띄어쓰기 ↓결과 전각문자로 띄어쓰기 줄바꿈 문장 끝에 띄어쓰기 두번혹은 문장 중간이나 끝에 &lt;br&gt; 로 줄바꿈을 할 수 있다. 예시 123문장 끝에 띄어쓰기를 두번하면 줄이 바뀐다. 이렇게 &lt;br&gt; 띄어쓰기도 &lt;br&gt; 가능 &lt;br&gt; 하다 ↓결과 문장 끝에 띄어쓰기를 두번하면 줄이 바뀐다. 이렇게 띄어쓰기도 가능 하다 강조 예시 123456789101112*이탤릭체* _이탤릭체_ **굵은 폰트** __굵은 폰트__ ***이탤릭 굵은 폰트*** ___이탤릭 굵은 폰트___~~중간선 폰트~~문장 중간에 사용할 경우 **띄어쓰기** 를 사용하는 것이 좋다. ↓결과 이탤릭체이탤릭체 굵은 폰트굵은 폰트 이탤릭 굵은 폰트이탤릭 굵은 폰트 중간선 폰트 문장 중간에 사용할 경우 띄어쓰기 를 사용하는 것이 좋다. 구분선 회색 선을 그어서 줄을 구분할 수 있다. 예시 12345678910---***- - -* * *// `-` 나 `*` 를 3번이상 적으면 상관없이 줄이 그어진다.--------------************** ↓결과 // 3번이상 적으면 상관없이 줄이 그어진다. 인용구(BlockQuotes) &gt;주로 남의 말이나 글, 또는 자료에서 따온 문장을 쓸때 사용한다. 예시 12345678&gt; 인용문1&gt; 중첩인용구1 &gt; 중첩인용구11&gt;&gt; 중첩인용구2&lt;br&gt;&gt;&gt; 중첩인용구22&gt;&gt;&gt; 중첩인용구3 &gt;&gt;&gt; 중첩인용구33 ↓결과 인용문1 중첩인용구1중첩인용구11 중첩인용구2중첩인용구22 중첩인용구3중첩인용구33 목록(리스트) 순서가 없는 리스트 순서대로 숫자로 이루어진 것이 아닌 list-style이 있는 상태이다. - , + , * 서로 혼용이 가능하다. 예시 12345678910+ 리스트P- 리스트M* 리스트S- 리스트1.0 + 리스트1.1 * 리스트1.2 - 리스트1.3 + 리스트1.4 * 리스트 1.5 ↓결과 리스트P 리스트M 리스트S 리스트1.0 리스트1.1 리스트1.2 리스트1.3 리스트1.4 리스트 1.5 순서가 있는 리스트 순서대로 숫자로 이루어진 리스트이다. 예시 12345678910111. 리스트 11. 리스트 21. 리스트 3 // 순서가 있는 리스트 내부의 리스트도 자동으로 정렬된다.1. 리스트 4-1 1. 리스트 4-1-1 1. 리스트 4-1-2 1. 리스트 4-1-3 1. 리스트 4-1-3-1 1. 리스트 4-1-3-2 1. 리스트 4-1-3-3 ↓결과 리스트 1 리스트 2 리스트 3 // 순서가 있는 리스트 내부의 리스트도 자동으로 정렬된다. 리스트 4-1 리스트 4-1-1 리스트 4-1-2 리스트 4-1-3 리스트 4-1-3-1 리스트 4-1-3-2 리스트 4-1-3-3 코드블럭 코드가 한 줄일 경우에는 코드의 앞과 뒤로 ` (싱글쿼테이션(ESC키 밑에 있는 키)) 를 입력해 주면 된다. 예시 1한 줄 코드 `int i = 0;` 이다 ↓결과 한 줄 코드 int i = 0; 이다 코드가 여러 줄일 경우에는 ``` 또는 ~~~ 로 감싸줘야한다. 예시 123456```for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)}``` 123456~~~for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)}~~~ ↓결과 1234for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)} 1234for(int i = 0; i &lt; 10; i++){ System.out.println(&quot;hello, World!&quot;)} 링크 외부 링크 인라인 링크: [링크제목](http://www.google.com)결과: 링크제목 참조 링크: 그것은 [여기에][1]있다.1[1]: http://www.google.com 결과: 그것은 여기에있다. url 링크: &lt;http://www.google.com&gt;결과:&amp;nbsp; http://www.google.com 내부 링크 예시 : [링크제목](#링크아이디)결과 : 링크제목 이미지 ![사진이름](사진경로) 예시![고양이](https://cdn.pixabay.com/photo/2019/11/08/11/56/cat-4611189_960_720.jpg) ↓결과 테이블(표) 예시 123456|이름|나이|성별||---|----|----||홍길동|25|남||김나미|30|여||안보영|35|여||대장균|40|남| ↓결과 이름 나이 성별 홍길동 25 남 김나미 30 여 안보영 35 여 대장균 40 남 테이블 정렬 오른쪽 정렬: —: 가운데 정렬: :—: 왼쪽 정렬: :— 예시 123456|이름|나이|성별||:---|:----:|----:||홍길동|25|남||김나미|30|여||안보영|35|여||대장균|40|남| ↓결과 이름 나이 성별 홍길동 25 남 김나미 30 여 안보영 35 여 대장균 40 남 주석 &lt;!-- 주석내용 --&gt; 주석은 출력결과가 나타나지 않는다. 예시 1&lt;!-- 주석내용1234 --&gt; ↓결과 윗/아랫첨자 글자에 제곱2 을 표시하고 싶거나로그log10 를 표시하고 싶을때 사용한다. 예시 12345678이것은 ^윗첨자^이다. 이것도 &lt;sup&gt;윗첨자&lt;/sup&gt; 이다.// ^ 와 ~ 가 안먹힐때는 // &lt;sup&gt;&lt;/sup&gt; 혹은 &lt;sub&gt;&lt;/sub&gt; 로 글자를 감싸주면 된다. 이것은 ~아랫첨자~이다.이것도 &lt;sub&gt;아랫첨자&lt;/sub&gt;이다. ↓결과 이것은 ^윗첨자^이다.이것도 윗첨자 이다. 이것은 아랫첨자이다.이것도 아랫첨자이다.","link":"/2022/04/01/Markdown%EC%A0%95%EB%A6%AC/"},{"title":"객체와 클래스 및 객체지향 언어의 특징","text":"객체와 클래스 객체란? 구체적 추상적 데이터의 단위 객체의 속성은 클래스의 맴버 변수로 선언 한다 클래스의 모양 그대로 찍어낸 실체 프로그램 실행중에 생성되는 실체 메모리 공간을 갖는 구체적인 실체 인스턴스(instance)라고도 부른다. 클래스란? 객체를 만들어내기 위한 설계도 혹은 틀 객체의 속성(state)과 행동(behavior) 포함. 예) 클래스 객체 사람 나, 너, 이웃집아저씨 붕어빵틀 구워진 붕어빵 여러개 소나타 자동차 출고된 실제 소나타 20대 객체지향 프로그래밍(OOP)이란? 프로그램의 구현을 시간의 흐름순이 아닌 객체간의 관계와 협력을 기반으로 프로그래밍 하는것이다. 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징을 뽑아와 프로그래밍 하는것 객체를 정의하고 각 객체의 속성을 맴버 변수로 역활을 매서드로 구현하고 각 객체간의 협력을 구현한다. 객체지향 프로그래밍의 장점 소프트웨어의 생산성 향상 컴퓨터 산업의 발전에 따라 소프트웨어의 생명 주기(Life Cycle)단축 소프트웨어를 빠른 속도로 생산할 필요성 증대 객체지향 언어 캡슐화, 상속, 다형성, 객체 등 소프트웨어 재사용을 위한 여러 장치가 내장되있음. 소프트웨어 재사용과 부분 수정이 빠름 소프트웨어를 다시 만드는 부담 줄어들음 소프트웨어 생산성 향상. 실세계에 대한 쉬운 모델링 컴퓨터 산업 초기때는 수학계산/통계 처리를 하는 등의 처리과정, 계산 절차가 중요했지만 현대에는 절차나 과정보다 물체(객체)들의 상호작용으로 묘사하는 것이 용이해졌기 때문 보안성 향상 객체지향의 캡슐화 특징으로 실제 구현되는 부분을 외부에서 볼 수 없으므로 정보 은닉 가능. 객체지향 프로그래밍의 단점 느린 개발속도 모든 객체의 역활과 기능을 이해해야 하기 때문에 프로그래밍에 많은 시간이 소모된다. 느린 실행속도 절차지향 프로그래밍에 비해 느린 실행속도 메모리와 연산에 대한 비용이 증가한다. 높은 난이도 절차지향 프로그래밍에 비해 난이도가 높다. 객체지향 언어(Object-oriented Language) 객체지향 언어란 프로그램을 다수의 객체로 만들고, 이 객체끼리 서로 상호작용 하도록 만드는 프로그래밍 언어이다. 여기서 객체란, 현실로 따지면 TV, 책, 냉장고, 컴퓨터, 카메라 등이 모두 객체인 것이다. 객체는 객체마다 고유한 특성과 행동을 가진다. 객체지향 언어의 특징 캡슐화 (encapsulation) 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것 외부의 접근으로 부터 객체를 보호해 준다. 데이터와 코드의 형태를 외부에서 알 수 없다. 상속 (inheritance) 상위 객체의 속성이 하위 객체에 물려지는것 하위 객체가 상위 객체의 속성을 모두 가지는 관계 Java는 클래스의 다중 상속이 불가능하다. 하지만 인터페이스 다중 상속은 가능하다. 다형성 (polymorphism) 상속과 연관된 개념으로, 같은 이름의 메소드나 클래스가 객체에 따라 다르게 동작하도록 구현한 것 다시말해, 하나의 객체가 다른 여러 객체로 재구성 되는 것이다. 오버로딩(Overloading), 오버라이딩(Overriding)이 있다. 오버로딩(Overloading): 같은 이름인 함수를 여러개 정의한 후 매개변수를 다르게 하여 각자 다르게 동작하는 것 오버라이딩(Overriding): 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현한 것 추상화 (abstraction) 객체들의 공통된 특징(기능, 속성)을 도출하는 것이다. 클래스를 정의하는 것을 추상화라고 할 수 있다.","link":"/2022/04/12/%EA%B0%9D%EC%B2%B4%EC%99%80%20%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%B0%8F%20%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%96%B8%EC%96%B4%EC%9D%98%20%ED%8A%B9%EC%A7%95/"},{"title":"인스턴스 및 생성자","text":"메서드 (method) 객체의 기능을 구현하기 위해 클래스 내부에 구현되는 함수 맴버 변수를 이용하여 클래스의 기능을 구현한 함수 메서드의 이름은 그 객체를 사용하는 객체에 맞게 짓는것이 좋음 인스턴스 (instance) 클래스명 참조변수명 = new 클래스명(); 클래스는 객체의 속성을 정의 하고, 기능을 구현하여 만들어 놓은 코드 상태이다. 실제 클래스 기반으로 생성된 객체(인스턴스)는 각각 다른 맴버 변수 값을 가지게 된다. new 키워드를 사용하여 인스턴스 생성. 생성자 (constructor) 생성자 선언: 접근제어지시자 클래스명(매개변수) {} 객체를 생성할 때 new 키워드와 함께 사용 생성자는 매개변수가 없는 기본 생성자와 매개변수를 여러개 받는 생성자를 만들 수 있다. 생성자는 일반 함수처럼 기능을 호출하는 것이 아니고 객체를 생성하기 위해 new 와 함께 호출됨. 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출함. 생성자는 반환 값이 없고, 클래스의 이름과 동일하다. 대부분의 생성자는 외부에서 접근이 가능하지만, 필요에 의해 private로 선언되는 경우가 있다. 기본 생성자 (default constructor) 클래스에는 반드시 하나 이상의 생성자가 존재해야 한다. 클래스에 생성자를 구현하지 않아도 new 키워드와 함께 생성자를 호출 가능하다. 클래스에서 생성자가 하나도 없는 경우 컴파일러에서 생성자 코드를 넣어준다.","link":"/2022/04/14/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%20%EB%B0%8F%20%EC%83%9D%EC%84%B1%EC%9E%90/"},{"title":"알고리즘 및 빅오 표기법","text":"알고리즘이란? 어떤 문제가 주어졌을 때, 문제를 풀기 위한 동작들의 절차 예) 집에서 학교가는법, 일어서는법, 라면끓이는 법 등등…. Input값을 통해 Output 결과를 내는 과정 빅오 표기법 점근 표기법의 종류중 한 개 이다. 복잡도를 이야기 할 때 가장 기본이 되는 상한 점근 방식이다. 여러가지 알고리즘 방법들을 시간과 공간 측면에서 비교할 수 있게 도와준다. 공간복잡도 데이터 관리에 필요한 공간 데이터 양의 변화에 따른 공간 변화 예상 소요 공간 측정 시간복잡도 데이터 처리에 소요되는 시간 데이터 양의 변화에 따른 소요 시간의 변화 예상 처리 시간을 측정한다. 지연 장애가 발생했을 때 왜 발생했는지를 찾을 수 있는 근거가 된다. O(1) 입력 데이터의 크기와 상관 없이 항상 일정한 시간이 걸리는 알고리즘 배열의 Random Access, Hash O(N) 입력 데이터의 크기에 비례해서 시간이 소요되는 알고리즘 for문 123for(int i = 0; i &lt; N; i++) { .....} O(N2) 입력 데이터의 제곱에 비례해서 시간이 소요되는 알고리즘 2중 for문 12345for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; N; j++){ ..... }} O(logN) 이진탐색(Binary Search) 검색할 배열의 중간값을 가지고 찾고싶은 숫자의 값이 배열이 중간값보다 큰지 작은지 비교후 크면 오른쪽을, 작으면 왼쪽을 부분배열로 나눠서 또 다시 중간값을 가져와서 비교 후 수를 찾는 알고리즘 O(NlogN) Merge sort 주어진 데이터의 집합에서 절반씩 나누면서 하나씩 값을 비교해 가면서 다시 정렬을 해 나가면서 데이터의 N번만큼 값을 비교해 나가는 알고리즘","link":"/2022/04/11/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC%20%EB%B9%85%EC%98%A4%20%ED%91%9C%EA%B8%B0%EB%B2%95/"},{"title":"접근제어 지시자와 정보 은닉","text":"접근 제어 지시자 클래스 외부에서 클래스의 맴버 변수, 메서드, 생성자를 사용할 수 있는지 여부를 지정하는 키워드. private : 같은 클래스 내부에서만 접근 가능(외부 클래스, 상속 관계의 클래스에서도 접근 불가) 아무것도 없음(default) : 같은 패키지 내부에서만 접근 가능(상속 관계라도 패키지가 다르면 접근 불가) protected : 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근할 수 없음 public : 클래스의 외부 어디서나 접근할 수 있음 get()/set() 메서드private으로 선언된 맴버 변수(필드)에 대해접근. this this는 인스턴스 자신의 메모리를 가리킨다 생성자에게 또 다른 생성자를 호출 할때 사용 자신의 주소(참조값)을 반환함 static static변수 여러 인스턴스가 공유하는 기준 값이 필요한 경우 공통으로 사용하는 변수가 필요한 경우 학생마다 새로운 학번 생성 카드회사에서 카드를 새로 발급할때마다 새로운 카드 번호를 부여 회사에 사원이 입사할때 마다 새로운 사번이 필요할때 static변수는 인스턴스를 생성하지 않고도 클래스 이름으로 참조해 출력 가능하다. static 메서드 static 메서드 안에서는 인스턴스 변수(일반 맴버 변수)를 사용할 수 없다 왜냐하면 일반 맴버 변수가 메모리에 생성이 안된 상태일수도 있기 때문이다. 싱글톤 패턴 싱글톤 패턴이란 인스턴스가 단 한개만 생성되어야 하는 경우 사용하는 디자인 패턴이다. static변수, 메서드를 활용하여 구현 할 수 있다","link":"/2022/04/13/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4%20%EC%A7%80%EC%8B%9C%EC%9E%90%EC%99%80%20%EC%A0%95%EB%B3%B4%20%EC%9D%80%EB%8B%89/"},{"title":"커밋 컨벤션 정리","text":"Commit Message Convention커밋 컨벤션을 쓰는 이유 팀원들과 커뮤니케이션을 원활하게 하기 위해서 일관성있게 각 커밋의 위치에서 무엇을 했나 한눈에 확인하기 위해 시각적 통일성을 확보하기 위해서 해당 커밋에 대한 어떤 내용이 이루어졌는지 파악하기 위해서 과거 코드에 대한 코드 추적을 원활하게 하기 위해서 커밋 컨벤션 정리 Commit frefix 용도 feat: 내용 새로운 기능을 추가할 경우 docs: 내용 문서파일을 생성하거나 수정한 경우 conf: 내용 설정파일을 생성하거나 수정한 경우 test: 내용 테스트를 추가, 리펙토링 했을경우 fix: 내용 올바르지 않은 동작을 고친 경우 refactor: 내용 동작을 더 괜찮게 고쳤을 경우 ci: 내용 CI 관련 설정을 수정한 경우 build: 내용 빌드 관련 파일을 수정한경우 perf: 내용 성능을 향상시키는 코드로 변경한경우","link":"/2022/04/10/%EC%BB%A4%EB%B0%8B%20%EC%BB%A8%EB%B2%A4%EC%85%98%20%EC%A0%95%EB%A6%AC/"},{"title":"컴퓨터의 자료 표현 방법","text":"컴퓨터는 0과 1로만 데이터를 저장한다. 1bit 는 컴퓨터가 표현하는 데이터의 최소 단위로 2진수 하나의 값을 저장할 수 있는 메모리의 크기이다. 1byte는 8bit 다. 진수 표현 16진수 2 4 8 A 10진수 2 4 8 10 8진수 2 4 10 12 2진수 0010 0100 1000 1010 8bit(1byte)로 5를 표현하면0 0 0 0 0 1 0 1 ↑ 맨 첫번째 비트는 부호비트(MSB)이다. 비트로 나타낼 수 있는 수의 개수는 2 ^ N개의 비트 비트로 나타낼 수 있는 수의 범위는 2 ^ N개의 비트 - 1 Java에서 각종 진수 표현하기 진수 변수 초기화 값 2진수 0B 8진수 0 16진수 0X 예) 결과)","link":"/2022/04/06/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98%20%EC%9E%90%EB%A3%8C%20%ED%91%9C%ED%98%84%20%EB%B0%A9%EB%B2%95/"}],"tags":[{"name":"Git Bash 명령어","slug":"Git-Bash-명령어","link":"/tags/Git-Bash-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Java의 역사","slug":"Java의-역사","link":"/tags/Java%EC%9D%98-%EC%97%AD%EC%82%AC/"},{"name":"Java의 특징","slug":"Java의-특징","link":"/tags/Java%EC%9D%98-%ED%8A%B9%EC%A7%95/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"release version ?? not supported","slug":"release-version-not-supported","link":"/tags/release-version-not-supported/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"객체지향 프로그래밍","slug":"객체지향-프로그래밍","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"객체지향 언어","slug":"객체지향-언어","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%96%B8%EC%96%B4/"},{"name":"객체와 클래스","slug":"객체와-클래스","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"},{"name":"생성자","slug":"생성자","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"접근제어 지시자","slug":"접근제어-지시자","link":"/tags/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4-%EC%A7%80%EC%8B%9C%EC%9E%90/"},{"name":"정보 은닉","slug":"정보-은닉","link":"/tags/%EC%A0%95%EB%B3%B4-%EC%9D%80%EB%8B%89/"},{"name":"커밋 컨벤션","slug":"커밋-컨벤션","link":"/tags/%EC%BB%A4%EB%B0%8B-%EC%BB%A8%EB%B2%A4%EC%85%98/"},{"name":"Commit Convention","slug":"Commit-Convention","link":"/tags/Commit-Convention/"},{"name":"컴퓨터의 자료 표현 방법","slug":"컴퓨터의-자료-표현-방법","link":"/tags/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-%EC%9E%90%EB%A3%8C-%ED%91%9C%ED%98%84-%EB%B0%A9%EB%B2%95/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Git Bash 명령어","slug":"Git/Git-Bash-명령어","link":"/categories/Git/Git-Bash-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Java","slug":"Programming/Java","link":"/categories/Programming/Java/"},{"name":"Algorithm","slug":"Programming/Algorithm","link":"/categories/Programming/Algorithm/"},{"name":"Linux 명령어","slug":"Git/Linux-명령어","link":"/categories/Git/Linux-%EB%AA%85%EB%A0%B9%EC%96%B4/"},{"name":"커밋 컨벤션","slug":"Git/커밋-컨벤션","link":"/categories/Git/%EC%BB%A4%EB%B0%8B-%EC%BB%A8%EB%B2%A4%EC%85%98/"},{"name":"CS","slug":"Programming/CS","link":"/categories/Programming/CS/"},{"name":"Markdown 문법 정리","slug":"Markdown/Markdown-문법-정리","link":"/categories/Markdown/Markdown-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/"},{"name":"객체지향","slug":"Programming/Java/객체지향","link":"/categories/Programming/Java/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"인스턴스 및 생성자","slug":"Programming/Java/인스턴스-및-생성자","link":"/categories/Programming/Java/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%B0%8F-%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"접근제어 지시자","slug":"Programming/Java/접근제어-지시자","link":"/categories/Programming/Java/%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4-%EC%A7%80%EC%8B%9C%EC%9E%90/"},{"name":"IDE","slug":"Programming/Java/IDE","link":"/categories/Programming/Java/IDE/"},{"name":"Error모음","slug":"Programming/Java/IDE/Error모음","link":"/categories/Programming/Java/IDE/Error%EB%AA%A8%EC%9D%8C/"}]}